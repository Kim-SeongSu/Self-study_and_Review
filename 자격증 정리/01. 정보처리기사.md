<img src="https://capsule-render.vercel.app/api?type=transparent&color=00000&height=100&section=header&fontSize=50&descAlign=62&descSize=20&descAlignY=81&text=🌟%20정보처리기사%20정리%20🌟"/>

# ✳️ 과목 1. 소프트웨어 설계
## 💠Chapter 01. 소프트웨어 개발 방법론
### 🔹Section 01. **소프트웨어 개발 방법론 ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [X] **플랫폼 (flatform)** 
> - [X] **프레임워크 (FrameWork)**
> - [ ] **SDLC (소프트웨어 개발 수명 주기)**
> - [ ] **애자일**
> - [ ] **소프트웨어 개발 방법론**

ㅤ✔ **플랫폼 (flatform)**<br>
ㅤㅤㅤ: 특정 시스템을 바탕으로 제공되는 `운영체제 및 운영환경` <br><br>

ㅤ✔ **프레임워크 (FrameWork)**<br>
ㅤㅤㅤ: `디자인 패턴`에 `모듈`의 장점 및 기능을 결합하여 실제적인 개발의 틀을 제공 <br>
ㅤㅤㅤㅤ🔻 **모듈 (Module)** - 프로그램을 기능별로 분할하여 재사용이 가능하게끔 부품화한 것 <br>
ㅤㅤㅤㅤ🔻 **라이브러리 (Library)** - 관련 있는 모듈들을 모아놓은 것 (=툴킷) <br>
ㅤㅤㅤㅤ🔻 **디자인 패턴 (Design Pattern)** - 특정 기능에 대한 문제해결을 위한 추상적인 가이드라인 제시 및 프로그램의 세부적인 구현 방안을 위해 참조하는 해결 방식 제시<br>
ㅤㅤㅤㅤ🔻 **소프트웨어 아키텍처 (Architecture)** - 다수의 프레임워크를 체계적으로 구성, 설명하는 구조체<br>
ㅤㅤㅤㅤ🔻 **컴포넌트 (Component)** - 모듈의 형태로 재사용 가능한 확장된 소프트웨어 블럭<br><br>

ㅤ✔ **SDLC (소프트웨어 개발 수명 주기)**<br>
ㅤㅤㅤ: 소프트웨어 개발 과정을 `단계별로 구성`한 것 <br>
ㅤㅤㅤㅤ`'계획 → 설계 → 구현 → 테스트 → 배포 → 유지 관리'` 과정을 거침 <br>
ㅤㅤㅤㅤ**🔶SDLC 모델**<br>
ㅤㅤㅤㅤ🔻 **폭포수(Waterfall) 모델** - 단계별로 결과물이 명확하게 산출되어야 다음 단계로 넘어가는 방식<br>
ㅤㅤㅤㅤ🔻 **프로토타입(Prototype) 모델** - 시제품(Prototype)을 통해 최종 결과물 예측 가능한 개발<br>
ㅤㅤㅤㅤ🔻 **나선형(Spiral) 모델** - 나선을 돌듯이 여러 번의 지속적인 개발 과정을 통해 점진적으로 개발<br>
ㅤㅤㅤㅤ🔻 **애자일(Agile) 모델** - `고객과의 소통`에 중심을 둔 방법론들의 통칭<br>
ㅤㅤㅤㅤㅤㅤ※ **스크럼**[^1] **(Scrum) 모델**, **XP**[^2]**(eXtreme Programming) 모델**, FDD(기능 주도 개발), ASD(적응형 소프트웨어 개발), DSDM(동적 시스템 개발) 등이 있다.<br><br>

ㅤ✔ **소프트웨어 개발 방법론**<br>
ㅤㅤㅤ: 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법을 말함<br>
ㅤㅤㅤㅤ🔻 **구조적 방법론** - Yourdon에 의해 개발. 구조적 분석을 통해 고객의 요구사항을 **자료 흐름도(DFD)** 로 표현<br>
ㅤㅤㅤㅤ🔻 **정보공학 방법론** - 개발 단계별 정형화된 기법들을 통합 적용한 데이터 중심 방법론. **ERD(개체-관계 다이어그램)** 사용<br>
ㅤㅤㅤㅤ🔻 **객체지향 방법론** - 실체(Entity)를 독립된 형태의 객체(Object)로 표현하고, 객체들 간 메시지 교환을 통해 상호작용하도록 프로그램을 개발하는 방법론[^3]<br>
ㅤㅤㅤㅤ🔻 **컴포넌트 기반(CBD[^4]) 방법론** - 컴포넌트들을 조립해서 하나의 새로운 프로그램을 개발하는 방법론<br>
ㅤㅤㅤㅤ🔻 **애자일 방법론** - 수시로 변하는 `상황`과 `고객의 요구사항`을 바로바로 반영하여 개발하는 방법론<br>
ㅤㅤㅤㅤ🔻 **제품 계열 방법론** - 특정 제품에 적용(ex. 임베디드 소프트웨어)하고 싶은 공통된 기능을 개발하는 방법론<br><br>

ㅤ✔ **소프트웨어 보안 개발 방법론**<br>
ㅤㅤㅤ: 소프트웨어의 보안 취약점을 최소화하기 위한 지침 및 사례를 기반으로 개발하는 방법론<br>
ㅤㅤㅤㅤ🔻 **MS-SDL** - 마이크로소프트사가 자체적으로 수립한 소프트웨어 개발 모델<br>
ㅤㅤㅤㅤ🔻 **Seven Touchpoint** - 실무적으로 검증된 소프트웨어 보안의 `모범 사례` 7가지[^5]를 개발 모델에 통합한 것<br>
ㅤㅤㅤㅤ🔻 **CLASP** - 소프트웨어 개발 초기 단계의 보안을 강화하기 위한 `정형화`된 절차[^6] <br>
ㅤㅤㅤㅤ🔻 **CWE** - `소프트웨어 보안 취약점을 유발하는 원인`을 7가지로 정의[^7]한 방법론<br><br><br>

[^1]: `스크럼 팀`을 구성하여 `팀을 중심`으로 개발의 효율성을 높이는 개발 모델. **제품 책임자**, **스크럼 마스터**, **개발팀**으로 구성된다. (*중요 용어: *스프린트*, *테스크*)
[^2]: `고객의 참여`와 `짧은 개발 과정의 반복`을 극대화하여 개발 생산성을 높이는 개발 모델 (*중요 용어: *소규모 릴리즈*, *스파이크*, *이터레이션*)
[^3]: 객체지향 방법론의 기본 원칙으로 '**캡슐화, 정보은닉, 추상화, 상속성, 다형성**'가 있다.
[^4]: Component Based Develoment
[^5]: 코드 검토(code review), 아키텍처 위험 분석(architectural risk analysis), 침투 테스트(penetration testing), 위험 기반 보안 테스트(risk-base security testing), 악용 사례(abuse cases), 보안 요구(security requirement), 보안 운영(security operation)
[^6]: **개념, 역할 기반, 활동 평가, 활동 구현, 취약성**의 5가지 관점에 따라 보안 절차 진행
[^7]: 입력 데이터 검증 및 표현, 보안 기능, 시간 및 상태, 에러 처리, 코드 오류, 캡슐화, API 오용


### 🔹Section 02. **소프트웨어 개발 방법론 테일러링 ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [ ] **PERT**
> - [ ] **CPM**
> - [ ] **LOC**
> - [ ] **COCOMO**
> - [ ] **CMM**
> - [ ] **SPICE**

ㅤ✔ **방법론 테일러링**<br>
ㅤㅤㅤ: 개발 프로젝트의 특성 및 필요에 따라 기존의 소프트웨어 개발 모델을 **최적화**하는 활동<br><br>

ㅤ✔ **프로젝트 일정 계획 방법론**<br>
ㅤㅤㅤ: 소요 기간의 예측 가능성에 따라 **PERT**, **CPM** 등으로 나눔<br>
ㅤㅤㅤㅤ🔻 **PERT[^8]** - **작업별 개발 기간이 불확실**하여 `개발 기간 내에 전체 프로젝트를 완료할 수 있을지에 대한 확률을 분석`할 때 사용하는 방법<br>
ㅤㅤㅤㅤㅤㅤ❗중요 용어: *낙관치*, *기대치*, *비관치*, *예측치 = (낙관치 + (4 x 기대치) + 비관치) / 6* <br>
ㅤㅤㅤㅤ🔻 **CPM[^9] (임계 경로 기법)** - **작업별 개발 기간이 확실**한 경우에 사용하는 방법으로 `계획된 최단시간으로 전체 프로젝트를 완료하기 위한 주공정 경로와 소요 기간을 계산` <br>
ㅤㅤㅤㅤㅤㅤ❗중요 용어: *임계 경로*: **작업 소요시간이 가장 오래 걸리는 경로** <br>
ㅤㅤㅤㅤ🔻 **간트 차트(Gantt Chart)** - 프로젝트 개발 일정을 기능별로 시간에 흐름에 따라 막대 그래프를 사용하여 표현한 일정표<br><br>

ㅤ✔ **소프트웨어 비용 산정**<br>
ㅤㅤㅤ: 소프트웨어 비용을 결정하는 요소는 **프로젝트**, **자원**, **생산성**이 있다.<br>
ㅤㅤㅤㅤ🔶**하향식 비용 산정 기법** (과거의 유사한 개발 경험을 기반으로 비용을 산정하는 비과학적 기법)<br>
ㅤㅤㅤㅤㅤㅤ1️⃣ **전문가 측정 기법** - 2인 이상의 전문가들이 비용 산정<br>
ㅤㅤㅤㅤㅤㅤ2️⃣ **델파이(delphi) 측정 기법** - 조정자(Coordinator)가 여러 전문가의 의견을 종합하여 비용 산정 <br>
ㅤㅤㅤㅤ🔶**상향식 비용 산정 기법** (세부적인 작업 단위별로 비용 산정 후 전체 비용 산정하는 방식)<br>
ㅤㅤㅤㅤㅤㅤ1️⃣ **LOC(Line Of Code) 기법** - 각 기능의 소스 코드 라인 수의 **비관치, 낙관치, 기대치를 통해 예측치를 계산**하고 이를 기반으로 비용 산정<br>
ㅤㅤㅤㅤㅤㅤ2️⃣ **단계별 노력(Effort Per Task) 기법** - **각 기능들을 구현시키는데에 필요한 노력에 가중치를 별도 반영**하여 측정<br>
ㅤㅤㅤㅤㅤㅤ3️⃣**수학적 산정 기법**<br>
ㅤㅤㅤㅤㅤㅤㅤ- **COCOMO(COnstructive COst MOdel)** - Boehm(보임)이 제안한 LOC 기반 비용 산정 기법.<br>
ㅤㅤㅤㅤㅤㅤㅤㅤ❗**Organic(조직형): 5만 라인 이하 / Semi-Detached(반분리형): 30만 라인 이하 / Embedded(내장형): 30만 라인 이상** <br>
ㅤㅤㅤㅤㅤㅤㅤ- **Putnam(=생명 주기 예측 모형)** - Putnam이 제안. 대형 프로젝트의 노력 분포 산정에 이용. **시간에 따른 함수로 표현되는 Ray-leigh-Norden 곡선의 노력 분포도에 기반**<br>
ㅤㅤㅤㅤㅤㅤㅤ- **기능 점수(Function Point)** 알브레히트가 제안. S/W 기능을 증대시키는 요인(비용 산정 요인)별로 가중치를 부여하여 비용 산정<br><br>

ㅤ✔ **소프트웨어 품질 관리**<br>
ㅤㅤ🔻**CMM**(Capability Maturity Model) - `S/W 개발 업체들의 업무 능력 평가` 기준을 세우기 위한 **평가 능력 성숙도 모델**<br> 
ㅤㅤ🔻**CMMI**(Capability Maturity Model Integration) - 3가지 CMM 모델[^10]을 통합하여 발전된 형태의 **CMM 국제 공인 기준**<br>
ㅤㅤ🔻**SPICE[^11]** - S/W 품질 및 생산성 향상을 위한 **S/W 프로세스를 평가하는 국제 표준**. 0 → 5단계 <br> 
ㅤㅤ🔻**CASE[^12] 도구** - S/W 개발 프로세스의 전 과정에서 `개발자의 반복적인 작업량을 줄이기` 위한 **자동화를 지원하는 S/W 도구**<br><br>

ㅤ✔ **프로젝트 형상 관리**<br>
ㅤㅤ: S/W 개발 프로젝트의 모든 과정에서 발생하는 산출물들의 종합 및 변경과정(version)을 체계적으로 관리하고 유지하는 활동 및 기법. 이를 통해 변경 사항의 관리(reversion)가 가능<br>
ㅤㅤㅤ❗형상 관리 프로세스: `'형상 식별 / 형상 통제 / 형상 상태 보고 / 형상 감사'` <br><br><br>

[^8]: Program Evaluation and Review Technique
[^9]: Critical Path Method
[^10]: SW-CMM(S/W 개발 및 유지보수 관련 성숙도 모델), SE-CMM(시스템 엔지니어링 능력 성숙도 모델), IPD-CMM(프로젝트 간 협동/통합 프로젝트 개선 모델)
[^11]: Software Process Improvement and Capability dEtermination
[^12]: Computer Aided Software Engineering


## 💠Chapter 02. 요구사항 확인
### 🔹Section 01. **소프트웨어 개발 환경 분석 ( ⭐ )**
> [!IMPORTANT]
> - [ ] **업무 파악**
> - [X] **운영체제**
> - [ ] **DBMS**
> - [ ] **미들웨어**
> - [X] **오픈 소스**

ㅤ✔ **업무 파악** (현행 시스템 파악 절차)<br>

<div align="center">
  <img width="60%" src="https://private-user-images.githubusercontent.com/104110605/361131743-583abb75-ea77-4bfa-aaa7-74f8e0282c7a.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ0OTM1ODUsIm5iZiI6MTcyNDQ5MzI4NSwicGF0aCI6Ii8xMDQxMTA2MDUvMzYxMTMxNzQzLTU4M2FiYjc1LWVhNzctNGJmYS1hYWE3LTc0ZjhlMDI4MmM3YS5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQwODI0JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDgyNFQwOTU0NDVaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT00Y2Q5NmQ0NTA4MWJhY2FmNmE0YTE0MDliMWU5MzIyYTEyMzE1MGIzMTY4MWQ5YzE3MmQwOWNkMWFhYThjMjNlJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.Ac72YUktRSIo5O501R4I8x9LRmNeufbHcRwZfUzm-gg">
</div> <br>


ㅤ✔ **운영체제** (현행 시스템 파악 절차)<br>
ㅤㅤ: 사용자가 손쉽고 효율적으로 컴퓨터 시스템을 사용하도록 돕는 소프트웨어. H/W와 S/W 리소스를 관리하고 컴퓨터 프로그램을 위한 공통 서비스를 제공<br>
ㅤㅤㅤex) Microsoft Windows, UNIX, Linux, iOS, Android<br>

ㅤ✔ **DBMS(DataBase Management System)**<br>
ㅤㅤ: **사용자, 애플리케이션, 데이터베이스와 상호 작용하여 데이터를 저장, 관리, 상호작용하는 시스템**<br>
ㅤㅤㅤex) Oracle, MSSQL, MySQL, MongoDB<br>

ㅤ✔ **미들웨어(Middleware)** <br>
ㅤㅤ: **운영체제와 소프트웨어 애플리케이션 사이에 위치하여 운영체제가 제공하는 서비스를 확장하여 제공하는 소프트웨어**<br>

ㅤ✔ **오픈 소스(Open Source)** <br>
ㅤㅤ: 소스 코드를 무료로 공개하여 제한 없이 누구나 사용 및 제작이 가능한 소프트웨어<br><br><br>

### 🔹Section 02. **요구사항 확인 ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [ ] **요구사항 도출**
> - [ ] **유스케이스(Use Case) 다이어그램**
> - [ ] **기능/비기능적 요구사항**
> - [ ] **구조적 분석 도구**

ㅤ✔ **요구사항 도출 기법**<br>
ㅤㅤ: 사용자 요구사항은 불명확하고 변할 수 있기 때문에 다양한 도출 기법을 사용해야 함<br>
ㅤㅤㅤex) 인터뷰, 설문, 사용자 스토리, 업무절차 조사, 브레인 스토밍 회의, 프로토타이핑, 유스케이스[^13] <br>

ㅤ✔ **유스케이스(Use Case) 다이어그램**<br>
ㅤㅤ: **사용자와 다른 외부 시스템들이 목표 시스템을 이용하여 수행하는 기능을 사용자의 관점에서 표현한 도표** <br>
ㅤㅤ❗구성요소: **시스템 범위(Scope), 액터(actor / 주: 사용자, 부: 시스템), 유스케이스, 관계** <br>

ㅤ✔ **요구사항 분류(Requirement Classification)** <br> 
ㅤㅤ🔻**기능적 요구사항** - **시스템의 기능, 제어 연산, 기술에 대한 요구사항** <br>
ㅤㅤ🔻**비기능적 요구사항** - **성능, 보안, 품질, 안전 등에 대한 요구사항** <br>

ㅤ✔ **구조적 분석 도구** <br> 
ㅤㅤ🔻**자료 흐름도(DFD; Data Flow Diagram)** - **기능에 의한 데이터의 흐름을 도형으로 표현한 도표[^14]**.  <br>
ㅤㅤ🔻**자료 사전(DD; Data Dictionary)** - **자료 흐름도(DFD)에 사용된 데이터의 이름과 속성을 표기한 자료(Meta Data[^15])** <br>
ㅤㅤ🔻**NS**(Nassu-Schneiderman) **차트** - **문제 처리 프로세스를 도형을 통해 논리 중심으로 표현한 차트** <br>
ㅤㅤ🔻**HIPO**(Hierarchy Input Process Output) - **기능과 데이터의 관계를 여러 개의 고유 모듈로 분할하여 계층적[^16]으로 표현한 도표** <br>

ㅤ✔ **요구사항 검증 기법** <br> 
ㅤㅤ🔻**요구사항 검토(Review)** - 요구사항 검토 담당자들이 직접 요구사항 명세서 검증하는 방식 <br>
ㅤㅤㅤㅤ1️⃣ **동료(Peer) 검토** - 요구사항 명세서 **작성자가 다수의 동료들에게 직접 설명**하며 결함 분석 <br>
ㅤㅤㅤㅤ2️⃣ **워크스루(Walk Through)** - 미리 요구사항 명세서를 배포하여 **사전 검토 후 짧은 회의**를 통해 결함 분석 <br>
ㅤㅤㅤㅤ3️⃣ **인스펙션(Inspection)** - **요구사항 명세서 작성자 이외의 전문 검토 그룹**이 상세히 결함 분석 <br>
ㅤㅤ🔻**프로토타이핑** - 요구사항 검증을 위한 시제품 간단하게 개발하여 검증<br>
ㅤㅤ🔻**모델 검증** - 요구사항 분석 단계에서 개발된 모델이 요구사항을 만족하는 지 검증하는 방법<br>
ㅤㅤ🔻**인수(Acceptance) 테스트** - 개발이 완료된 소프트웨어를 직접 인수받아 인수자가 직접 테스트하여 요구사항 만족 여부를 검사하는 방법<br><br><br>

[^13]: 사용자 요구사항을 시스템 이용자와 기능, 관계로 표현
[^14]: **단말: 데이터 입출력 주체(사각형) / 프로세스: 데이터 처리 과정(타원) / 자료 흐름: 데이터 흐름 방향(화살표) / 자료 저장소: 데이터 저장 위치(상하 평행선)**
[^15]: **데이터의 정의 및 설명 등을 위해 사용하는 데이터**. `정의(=) / 연결(+) / 선택([ ] | [ ]) / 반복({ }) / 생략(( )) / 주석(* *)`
[^16]: 가시적 도표(Visual Table of Contents), 총체적 도표(Overview Diagram), 세부적 도표(Detail Diagram)로 나눔



### 🔹Section 03. **UML ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [ ] **사물(Thing)**
> - [ ] **다이어그램(Diagram)**
> - [ ] **관계(Relation)**

ㅤ✔ **UML(Unified Modeling Language)**<br>
ㅤㅤ: **개발자 간의 원화한 의사소통**을 위해 소프트웨어 공학에서 사용되는 **표준화된 범용 모델링 언어** <br><br>

ㅤ✔ **사물(Thing)**<br>
ㅤㅤ: **다이어그램 안에서 관계가 형성될 수 있는 대상** <br>  
ㅤㅤ🔻 **구조 사물** - **개념적, 물리적 요소**(Class, Interface, Usecase, Node ...)<br>
ㅤㅤ🔻 **그룹 사물** - **UML 요소들의 그룹화**<br>
ㅤㅤ🔻 **주해 사물** - UML에 대한 **부가적 설명, 주석** <br>
ㅤㅤ🔻 **행동 사물** - 각 요소들의 **행위, 상호작용** <br><br>

ㅤ✔ **다이어그램(Diagram)**<br>
ㅤㅤ: **사물과의 관계를 정형화된 도형으로 표현하여 의사소통에 도움을 주는 도구** <br>
ㅤㅤ🔻 **구조적(Structural) 다이어그램 (정적)** <br>
ㅤㅤㅤㅤ1️⃣ **클래스(Class) 다이어그램** - 클래스 간의 구조적인 관계 표현. **클래스명, 속성, 연산, 접근 제어자[^17]** 등으로 구성<br>
ㅤㅤㅤㅤ2️⃣ **객체(Object) 다이어그램** - 클래스의 인스턴스를 객체 간의 관계로 표현<br>
ㅤㅤㅤㅤ3️⃣ **컴포넌트(Component) 다이어그램** - 구현 단계에서 사용. 컴포넌트 간의 구성과 연결 상태 표현<br>
ㅤㅤㅤㅤ4️⃣ **배치(Deployment) 다이어그램** - 구현 단계에서 사용. 노드, 컴포넌트 등의 물리적인 아키텍처 표현 <br>
ㅤㅤㅤㅤ5️⃣ **복합체 구조(Composite Structure) 다이어그램** - 복합적인 구조를 갖는 컴포넌트, 클래스 등의 내부 구조 표현<br>
ㅤㅤㅤㅤ6️⃣ **패키지(Package) 다이어그램** - 같은 그룹의 하위 모듈들을 묶어주는 패키지 간의 의존 관계 표현 <br>

ㅤㅤ🔻 **행위적(Behavioral) 다이어그램 (동적)** <br>
ㅤㅤㅤㅤ1️⃣ **유스케이스(Use case) 다이어그램** - **사용자의 요구사항을 분석하여 기능을 중심으로 모델링한 결과물**을 표현 <br>
ㅤㅤㅤㅤ2️⃣ **시퀀스(Sequence) 다이어그램** - **객체들의 생성과 소멸, 객체들이 주고받는 메시지** 표현 <br>
ㅤㅤㅤㅤ3️⃣ **통신(Communication) 다이어그램** - 시퀀스 다이어그램 + 객체들의 연관 관계 표현<br>
ㅤㅤㅤㅤ4️⃣ **상태(State) 다이어그램** - 한 객체의 이벤트 활성에 따른 상태 변화 표현<br>
ㅤㅤㅤㅤ5️⃣ **활동(Activity) 다이어그램** - 객체의 프로세스나 로직의 처리 흐름을 순서에 따라 표현<br>
ㅤㅤㅤㅤ6️⃣ **상호작용(Interaction Overview) 다이어그램** - 통신, 시퀀스, 타이밍 등의 다이어그램 사이의 제어 흐름 표현<br>
ㅤㅤㅤㅤ7️⃣ **타이밍(Timing) 다이어그램** - 객체의 상태 변화와 시간 제약을 명시적으로 표현<br>

ㅤ✔ **관계(Relation)**<br>
ㅤㅤ: **사물과 사물의 연관성을 표현한 것** <br>
ㅤㅤ🔻 **연관(Association)** - **특정 사물**이 **다른 사물의 특성**을 지속적으로 **참조**하는 관계 `ex. [고객]ㅡ'대여하다'ㅡ[도서]` <br>
ㅤㅤ🔻 **집합(Aggregation)** - **사물(Part)이 다른 사물(Whole)에 포함**되어 있는 관계. 전체와 부분은 서로 **독립적** `ex. 컴퓨터 ◇ㅡ 마우스` <br>
ㅤㅤ🔻 **포함(Composition)** - **사물(Part)이 다른 사물(Whole)에 포함**되어 있는 관계. 전체와 부분은 서로 **종속적** `ex. 마우스 ◆ㅡ 마우스 리시버` <br>
ㅤㅤ🔻 **일반화(Generalization)** - 하나의 사물이 다른 사물에 대해 **상/하위 관계**를 가지는 것. `ex. 입력장치 ◁-- (마우스, 키보드, 마이크)` <br>
ㅤㅤ🔻 **의존(Dependency)** - **필요에 의해(조건에 따라)** 짧은 시간 동안만 관계를 유지하는 형태 `ex. 고객 --> 사은품`<br>
ㅤㅤ🔻 **실체화(Realization)** - **사물들의 공통적인 기능**을 상위 사물로 그룹화하여 표현 `ex. 정보제공 ◁-- (도서, 강사, 컴퓨터)` <br><br>

ㅤ✔ **스테레오 타입(Stereo type)**<br>
ㅤㅤ: UML의 기본적 요소 이외에 **새로운 요소를 만들어내는 확장 구조**들 중 하나. `<< >>` 기호 사용하여 표현 <br><br><br>

[^17]: public(+): **클래스 외부에서도 접근 허용 / private(-): 클래스 내부에서만 접근 허용 / default(~): 동일 패키지 클래스에서의 접근만 허용 / protected(#): 하위 클래스에서의 접근만 허용**


## 💠Chapter 03. 화면 설계
### 🔹Section 01. **UI 요구사항 ( ⭐ )**
> [!IMPORTANT]
> - [ ] **UI 구성 요소**
> - [ ] **UI 정의**
> - [ ] **웹 콘텐츠 접근성**
> - [ ] **UI 프로토타입**

ㅤ✔ **UI(User Interface)**<br>
ㅤㅤ: **사용자와 컴퓨터 상호 간의 원활한 소통을 도와주는 연계 시스템**. **CLI, GUI, NUI** 등이 있다. <br>

ㅤ✔ **UI element 종류**<br>
ㅤㅤ: **텍스트(Text) 박스, 라디오(Radio) 버튼, 토글(Toggle) 버튼, 콤보(Combo) 박스, 체크(Check) 박스, 명령(Command) 버튼** 등이 있다. <br>

<div align="center">
  <img width="50%" src="https://private-user-images.githubusercontent.com/104110605/361435212-4726c4de-e094-433d-8d48-4e9aa790d23b.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ2NzY0NjgsIm5iZiI6MTcyNDY3NjE2OCwicGF0aCI6Ii8xMDQxMTA2MDUvMzYxNDM1MjEyLTQ3MjZjNGRlLWUwOTQtNDMzZC04ZDQ4LTRlOWFhNzkwZDIzYi5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQwODI2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDgyNlQxMjQyNDhaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1mYzVhZGVhZjZmMDdiMzZhMzg3OWJkMTNhMDBlNzM5ZGYwZGIyYjJhNmRlYjk2MDdkY2E2Nzc3NTAxMzI3NDE0JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.0tp7vr49PGfZFAXj-V7_GKbM3R4a_6kRD9DTMGMrNVY">
</div> <br>

ㅤ✔ **웹 콘텐츠 접근성(Web Content Accessibility)**<br>
ㅤㅤ: 콘텐츠를 제공할 때, 디지털 약자를 위한 대체 형식의 콘텐츠를 함께 제공하는 것. 한국형 웹 콘텐츠 정의성 지침(Korea WCA Guideline)<br>

ㅤ✔ **UI 프로토타입**<br>
ㅤㅤ: UI에 대한 사용자 요구사항을 검증하기 위해 최대한 단순하게 제작한 시제품. Paper Prototype과 Digital Prototype이 있다.<br><br><br>

### 🔹Section 02. **UI 설계 ( ⭐ )**
> [!IMPORTANT]
> - [ ] **UI 설계 원칙**
> - [ ] **UI 설계 도구**
> - [ ] **HCI**
> - [x] **UX**

ㅤ✔ **UI 설계 원칙**<br>
ㅤㅤ: 직관성(쉽게 이해), 유효성(정확하게 전달), 학습성(쉽게 배움), 유연성 등이 있다. <br>

ㅤ✔ **UI 설계 도구**<br>
ㅤㅤ🔻 **와이어프레임** - 페이지에 대한 **대략적인 뼈대나 레이아웃만 설계**하여 나타냄<br>
ㅤㅤ🔻 **목업** - **실제 화면과 유사한 형태로 제작한 정적인(기능을 반영하지 않은) 모델**<br>
ㅤㅤ🔻 **스토리보드** - 와이어프레임 + **콘텐츠에 대한 설명** + **화면 간 이동 흐름**을 추가한 **문서** <br>
ㅤㅤ🔻 **프로토타입** - **특정 기능만을 간단하게 구현**하여 **테스트 및 피드백이 가능한 모델**<br>
ㅤㅤ🔻 **유스케이스** - 요구사항을 빠르게 파악하기 위해 **사용자의 요구사항을 기능 단위로 표현한 모델**<br>

ㅤ✔ **HCI(Human Computer Interface)**<br>
ㅤㅤ: 인간과 시스템의 상호작용이 보다 편리하고 안전하도록 연구하는 학문 <br>

ㅤ✔ **UX(User eXperience)** <br> 
ㅤㅤ: **사용자가 시스템을 이용하면서 느끼게 되는 종합적인 경험** **※ UI는 사용성과 편의성을 중시, UX는 이를 통해 느끼게 되는 만족감을 중시** <br><br><br>

## 💠Chapter 04. 애플리케이션 설계
### 🔹Section 01. **공통 모듈 설계 ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [ ] **재공학(Re-Engineering)**
> - [ ] **응집도(Cohesion)**
> - [ ] **결합도(Coupling)**
> - [ ] **공유도(Fan-In)**
> - [ ] **제어도(Fan-Out)**

ㅤ✔ **모듈화**<br>
ㅤㅤ: 프로그램이 효율적으로 관리될 수 있도록 시스템을 분해하고 추상화하는 기법 <br>

ㅤ✔ **소프트웨어 재공학(Re-Engineering)**<br>
ㅤㅤ: 기존의 시스템을 이용하여 보다 나은 시스템을 구축하는 방법 <br>
ㅤㅤ🔻 **분석(Analysis)** - 기존 소프트웨어의 명세를 통해 소프트웨어를 **분석하고 재공학 대상을 식별하여 재공학의 가치를 판단**하는 것 <br>
ㅤㅤ🔻 **재구성(Restructuring)** - 소프트웨어의 **기능이나 외적인 동작은 변형하지 않으면서 소프트웨어의 코드를 재구성하여 내부 구조와 품질을 향상**시키는 것 <br>
ㅤㅤ🔻 **역공학(Reverse Engineering)** - 외계인 코드(Alien Code)로부터 소프트웨어의 **소스 코드를 복구**하여 **설계 정보와 데이터 구조 정보 등을 추출** <br>
ㅤㅤ🔻 **이식(Migration)** - 기존 소프트웨어의 구조 및 기능을 **다른 플랫폼에서 사용할 수 있도록 변환**하는 것 <br>

ㅤ✔ **모듈 응집도(Cohension)** <br>
ㅤㅤ: 모듈의 내부 요소들의 관계가 얼마나 밀접한지를 나타내는 정도 <br>
ㅤㅤ❗낮음(낮음 품질) **| 우연 < 논리 < 시간 < 절차 < 통신 < 순차 < 기능 |** 높음(높은 품질)  <br>


ㅤ✔ **모듈 결합도(Coupling)**<br>
ㅤㅤ: 모듈과 모듈 간의 관련성이 얼마나 깊은지를 나타내는 정도 <br>
ㅤㅤ❗낮음(낮음 품질) **| 내용(Content) < 공통(Common) < 외부(External) < 제어(Control) < 스탬프(Stamp) < 자료(Data) |** 높음(높은 품질) <br>

ㅤ✔  **복잡도** <br>
ㅤㅤ🔻 **공유도(Fan-In)** <br>
ㅤㅤ: **자신을 호출(공유)하는 모듈의 수** <br>
ㅤㅤ🔻 **제어도(Fan-Out)** <br>
ㅤㅤ: **자신이 호출(제어)하는 모듈의 수** <br>

ㅤㅤ✅ **공유도와 응집도는 높게, 제어도와 결합도는 낮게**할 수록 **모듈의 독립성이 높아**진다. <br><br><br>


### 🔹Section 02. **시스템 연동 설계 ( ⭐⭐ )**
> [!IMPORTANT]
> - [ ] **코드 설계**
> - [ ] **소프트웨어 아키텍처**
> - [ ] **미드웨어 솔루션**
> - [ ] **재해 복구**

ㅤ✔  **코드(Code)** <br>
ㅤㅤ: **순차(Sequence) 코드, 블록(Block) 코드, 10진(Decimal) 코드, 그룹 분류(Group Classification) 코드, 연상(Mnemonic) 코드, 표의(Significant Digit) 코드, 합성(Combined) 코드** <br>

ㅤ✔  **시스템 연동** <br>
ㅤㅤ🔻 **인터페이스 연동** - API(Application Program Interface), RMI(Remote Method Invocation) 등을 통해서 다른 시스템과 연계하여 업무를 수행하는 체계<br>
ㅤㅤ🔻 **웹 서비스 연동** <br>
ㅤㅤㅤ1️⃣ **SOAP(Simple Object Access Protocol)** - 이기종 시스템의 데이터, 서비스 호출을 위한 XML 기반의 통신규약<br>
ㅤㅤㅤ2️⃣ **UDDI(Universal Description Discovery Integration)** - 간편한 웹 서비스 검색을 위한 XML 기반의 통합 레지스트리<br>
ㅤㅤㅤ3️⃣ **WSDL(Web Service Description Language)** - 웹 서비스를 기술하기 위한 XML 기반 표준 언어<br>

ㅤ✔  **소프트웨어 아키텍처** <br>
ㅤㅤ: **소프트웨어의 기본 구조를 정의한 것**. 소프트웨어 설계 및 구현을 위한 틀 제공 <br>
ㅤㅤ🔻**계층화(Layered) 패턴** - <br>
ㅤㅤ🔻**클라이언트/서버(Client/Server) 패턴** - <br>
ㅤㅤ🔻**마스터/슬레이브(Master/Slave) 패턴** - <br>
ㅤㅤ🔻**파이프-필터(Pipe-Filter) 패턴** - <br>
ㅤㅤ🔻**브로커 패턴(Broker)** - <br>
ㅤㅤ🔻**피어-투-피어(Peer-To-Peer) 패턴** - <br>
ㅤㅤ🔻**이벤트-버스(Event-Bus) 패턴** - <br>
ㅤㅤ🔻**MVC(Model, View, Controller) 패턴** - <br>
ㅤㅤ🔻**블랙보드(Blackboard) 패턴** - <br>
ㅤㅤ🔻**인터프리터(Interpreter) 패턴** - <br>

ㅤ✔  **미드웨어 종류별 특징** <br>
ㅤㅤ🔻**DBMS(DataBase Management System)** - <br>
ㅤㅤ🔻**RPC(Remote Procedure Call)** - <br>
ㅤㅤ🔻**MOM(Message Oriented Middleware)** - <br>
ㅤㅤ🔻**TP-Monitor(Transaction Processing Monitor)** - <br>
ㅤㅤ🔻**ORB(Object Request Broker)** - <br>
ㅤㅤ🔻**WAS(Web Application Server)** - <br>

ㅤ✔  **코드 오류** <br>
ㅤㅤ🔻**필사(Transcription) 오류** - <br>
ㅤㅤ🔻**전위(Transposition) 오류** - <br>
ㅤㅤ🔻**이중(Double) 전위 오류** - <br>
ㅤㅤ🔻**추가(Addition) 오류** - <br>
ㅤㅤ🔻**임의(Random) 오류** - <br>

ㅤ✔  **오류 대응방안** <br>
ㅤㅤ🔻**이중화** - <br>
ㅤㅤ🔻**재해 복구 시스템(DRS[^18])** - <br>
ㅤㅤㅤㅤ1️⃣ **Mirror Site** - <br>
ㅤㅤㅤㅤ2️⃣ **Hot Site** - <br>
ㅤㅤㅤㅤ3️⃣ **Warm Site** - <br>
ㅤㅤㅤㅤ4️⃣ **Cold Site** - <br>        
ㅤㅤㅤㅤㅤㅤRTO, RPO, BIA

[^18]: Disaster Recovery System

<br><br>

## 💠Chapter 05. 인터페이스 설계
### 🔹Section 01. **인터페이스 설계 ( ⭐ )**

<br><br><br> 

<!--
💠
ㅤ✔ ****<br>
공백문자: "ㅤ" or &nbsp;
### 🔹 ** **
ㅤㅤ:  <br>
ㅤㅤㅤex) <br>
ㅤㅤ✔ <br>
ㅤㅤㅤㅤㅤex) <br>
ㅤㅤ❓ <br>
ㅤㅤㅤㅤㅤex) <br>
ㅤㅤ❗ <br>
ㅤㅤㅤㅤㅤex) <br>

1️⃣ <br>
2️⃣ <br>
3️⃣ <br>
4️⃣ <br>
5️⃣ <br>
6️⃣ <br>
ㅤㅤㅤ:<br>
[]

> [!NOTE]  
> [!TIP]
> [!IMPORTANT]  
> [!WARNING]  
> [!CAUTION]

멀티테넌스[^1] 
[^1]:software multitenancy는 여러 테넌스(**사용자**)를 가진 소프트웨어 아키텍처라는 의미로 클라우드 서비스처럼 여러 사용자가 동시에 같은 작업을 진행할 수 있게하는 역할을 한다.


<div align="center">
  <img width="55%" src="https://velog.velcdn.com/images/okbear3/post/52d2f44d-f8f5-4ad7-b382-daa9b0186921/image.png">
</div>
-->



----------------------------------------------------------------------------------------------------------------------------

# ✳️ 과목 2. 소프트웨어 개발

## 💠Chapter 01. 자료 구조
### 🔹Section 01. **자료 구조 ( ⭐⭐⭐ )**

### 🔹Section 02. **탐색 - Search ( ⭐⭐ )**

### 🔹Section 03. **정렬 - Sorting ( ⭐⭐ )**

<br><br>

## 💠Chapter 02. 통합 구현
### 🔹Section 01. **연계 데이터 구성 ( ⭐ )**

### 🔹Section 02. **연계 메커니즘 구성 ( ⭐ )**

### 🔹Section 03. **연계 모듈 구현 ( ⭐⭐ )**

<br><br>

## 💠Chapter 03. 제품 소프트웨어 패키징
### 🔹Section 01. **제품 소프트웨어 패키징 ( ⭐⭐ )**

### 🔹Section 02. **제품 소프트웨어 메뉴얼 작성 ( ⭐ )**

### 🔹Section 03. **제품 소프트웨어 버전 관리 ( ⭐ )**

<br><br>

## 💠Chapter 04. 애플리케이션 테스트
### 🔹Section 01. **애플리케이션 테스트 케이스 설계 ( ⭐⭐⭐ )**

### 🔹Section 02. **애플리케이션 통합 테스트 ( ⭐⭐ )**

### 🔹Section 03. **애플리케이션 성능 개선 ( ⭐⭐⭐ )**


<br><br><br> 

----------------------------------------------------------------------------------------------------------------------------

# ✳️ 과목 3. 데이터베이스 구축

## 💠Chapter 01. 논리 데이터베이스 설계
### 🔹Section 01. **데이터베이스 기본 ( ⭐ )**

### 🔹Section 02. **논리 개체 상세화 ( ⭐ )**

### 🔹Section 03. **논리 E-R 다이어그램 ( ⭐ )**

### 🔹Section 04. **데이터베이스 정규화 ( ⭐⭐⭐ )**

<br><br>

## 💠Chapter 02. SQL 활용
### 🔹Section 01. **구조적 질의어 ( ⭐⭐⭐ )**

### 🔹Section 02. **SQL 활용 ( ⭐⭐⭐ )**

<br><br>

## 💠Chapter 03. 물리 데이터베이스 설계
### 🔹Section 01. **물리 속성 조사 분석 ( ⭐ )**

### 🔹Section 02. **데이터베이스 물리 속성 설계 ( ⭐ )**

### 🔹Section 03. **물리 데이터베이스 모델링 ( ⭐⭐ )**

<br><br>

## 💠Chapter 04. 데이터 전환
### 🔹Section 01. **데이터 전환 ( ⭐ )**

<br><br><br>

----------------------------------------------------------------------------------------------------------------------------

# ✳️ 과목 4. 프로그래밍 언어 활용

## 💠Chapter 01. 프로그래밍 개발 환경 구축
### 🔹Section 01. **프로그래밍 개발 환경 구성 ( ⭐ )**

<br><br>

## 💠Chapter 02. 절차형 프로그래밍 언어
### 🔹Section 01. **데이터 가공 및 입출력 ( ⭐⭐⭐ )**

### 🔹Section 02. **선택 및 반복 제어문 ( ⭐⭐⭐ )**

### 🔹Section 03. **자료 구조와 포인터 ( ⭐⭐⭐ )**

<br><br>

## 💠Chapter 03. 객체지향 프로그래밍 언어
### 🔹Section 01. **객체지향 방법론 ( ⭐⭐⭐ )**

### 🔹Section 02. **객체지향 프로그래밍 ( ⭐⭐⭐ )**

<br><br>

## 💠Chapter 04. 스크립트 프로그래밍 언어
### 🔹Section 01. **파이썬 프로그래밍 ( ⭐⭐⭐ )**

<br><br>

## 💠Chapter 05. 운영체제 활용
### 🔹Section 01. **운영체제 ( ⭐ )**

### 🔹Section 02. **프로세스 ( ⭐⭐⭐ )**

### 🔹Section 03. **기억 장치 관리 ( ⭐⭐ )**

<br><br><br>

----------------------------------------------------------------------------------------------------------------------------

# ✳️ 과목 5. 정보 시스템 구축 관리

## 💠Chapter 01. IT 프로젝트 정보 시스템 구축 관리
### 🔹Section 01. **네트워크 구축 관리 ( ⭐ )**

### 🔹Section 02. **통신망 기술 ( ⭐⭐ )**

### 🔹Section 03. **통신 프로토콜 ( ⭐⭐⭐ )**

### 🔹Section 04. **정보 시스템 신기술 동향 ( ⭐⭐⭐ )**

<br><br>

## 💠Chapter 02. 개발 보안 구축
### 🔹Section 01. **소프트웨어 개발 보안 구축 ( ⭐ )**

### 🔹Section 02. **시스템 보안 구축 ( ⭐ )**

<br><br>

## 💠Chapter 03. 암호 기술
### 🔹Section 01. **보안 공격 및 예방 ( ⭐⭐⭐ )**

### 🔹Section 02. **보안 솔루션 ( ⭐ )**

### 🔹Section 03. **암호 기술 ( ⭐⭐ )**

<br><br><br>

----------------------------------------------------------------------------------------------------------------------------
