<img src="https://capsule-render.vercel.app/api?type=transparent&color=00000&height=100&section=header&fontSize=50&descAlign=62&descSize=20&descAlignY=81&text=🌟%20정보처리기사%20정리%20🌟"/>

# ✳️ 과목 1. 소프트웨어 설계
## 💠Chapter 01. 소프트웨어 개발 방법론
### 🔹Section 01. **소프트웨어 개발 방법론 ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [X] **플랫폼 | 프레임워크 | SDLC | 애자일 | 소프트웨어 개발 방법론** 

✔ **플랫폼 (flatform)**<br>
ㅤ: 특정 시스템을 바탕으로 제공되는 `운영체제 및 운영환경` <br><br>

✔ **프레임워크 (FrameWork)**<br>
ㅤ: `디자인 패턴`에 `모듈`의 장점 및 기능을 결합하여 실제적인 개발의 틀을 제공 <br>
ㅤ🔻 **모듈 (Module)**: 프로그램을 기능별로 분할하여 재사용이 가능하게끔 부품화한 것 <br>
ㅤ🔻 **라이브러리 (Library)**: 관련 있는 모듈들을 모아놓은 것 (=툴킷) <br>
ㅤ🔻 **디자인 패턴 (Design Pattern)**: 특정 기능에 대한 문제해결을 위한 추상적인 가이드라인 제시<br> 
ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ및 프로그램의 세부적인 구현 방안을 위해 참조하는 해결 방식 제시<br>
ㅤ🔻 **소프트웨어 아키텍처 (Architecture)**: 다수의 프레임워크를 체계적으로 구성, 설명하는 구조체<br>
ㅤ🔻 **컴포넌트 (Component)**: 모듈의 형태로 재사용 가능한 확장된 소프트웨어 블럭<br><br>

✔ **SDLC (소프트웨어 개발 수명 주기)**<br>
ㅤ: 소프트웨어 개발 과정을 `단계별로 구성`한 것 <br>
ㅤㅤ`'계획 → 설계 → 구현 → 테스트 → 배포 → 유지 관리'` 과정을 거침 <br>
ㅤ**🔶SDLC 모델**<br>
ㅤ🔻 **폭포수(Waterfall) 모델**: 단계별로 결과물이 명확하게 산출되어야 다음 단계로 넘어가는 방식<br>
ㅤ🔻 **프로토타입(Prototype) 모델**: 시제품(Prototype)을 통해 최종 결과물 예측 가능한 개발<br>
ㅤ🔻 **나선형(Spiral) 모델**: 나선을 돌듯이 여러 번의 지속적인 개발 과정을 통해 점진적으로 개발<br>
ㅤ🔻 **애자일(Agile) 모델**: `고객과의 소통`에 중심을 둔 방법론들의 통칭<br>
ㅤㅤㅤ※ **스크럼**[^1] **(Scrum) 모델**, **XP**[^2]**(eXtreme Programming) 모델**, <br>
ㅤㅤㅤㅤFDD(기능 주도 개발), ASD(적응형 소프트웨어 개발), DSDM(동적 시스템 개발) 등이 있다.<br><br>

✔ **소프트웨어 개발 방법론**<br>
ㅤ: 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법을 말함<br>
ㅤ🔻 **구조적 방법론**: Yourdon에 의해 개발. 구조적 분석을 통해 고객의 요구사항을 **자료 흐름도(DFD)** 로 표현<br>
ㅤ🔻 **정보공학 방법론**: 개발 단계별 정형화된 기법들을 통합 적용한 데이터 중심 방법론. **ERD(개체-관계 다이어그램)** 사용<br>
ㅤ🔻 **객체지향 방법론**: 실체(Entity)를 독립된 형태의 객체(Object)로 표현하고, 객체들 간 메시지 교환을 통해 상호작용하도록 <br>
ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ프로그램을 개발하는 방법론[^3]<br>
ㅤ🔻 **컴포넌트 기반(CBD[^4]) 방법론**: 컴포넌트들을 조립해서 하나의 새로운 프로그램을 개발하는 방법론<br>
ㅤ🔻 **애자일 방법론**: 수시로 변하는 `상황`과 `고객의 요구사항`을 바로바로 반영하여 개발하는 방법론<br>
ㅤ🔻 **제품 계열 방법론**: 특정 제품에 적용(ex. 임베디드 소프트웨어)하고 싶은 공통된 기능을 개발하는 방법론<br><br>

✔ **소프트웨어 보안 개발 방법론**<br>
ㅤ: 소프트웨어의 보안 취약점을 최소화하기 위한 지침 및 사례를 기반으로 개발하는 방법론<br>
ㅤ🔻 **MS-SDL**: 마이크로소프트사가 자체적으로 수립한 소프트웨어 개발 모델<br>
ㅤ🔻 **Seven Touchpoint**: 실무적으로 검증된 소프트웨어 보안의 `모범 사례` 7가지[^5]를 개발 모델에 통합한 것<br>
ㅤ🔻 **CLASP**: 소프트웨어 개발 초기 단계의 보안을 강화하기 위한 `정형화`된 절차[^6] <br>
ㅤ🔻 **CWE**: `소프트웨어 보안 취약점을 유발하는 원인`을 7가지로 정의[^7]한 방법론<br><br><br>

[^1]: `스크럼 팀`을 구성하여 `팀을 중심`으로 개발의 효율성을 높이는 개발 모델. **제품 책임자**, **스크럼 마스터**, **개발팀**으로 구성된다. (*중요 용어: *스프린트*, *테스크*)
[^2]: `고객의 참여`와 `짧은 개발 과정의 반복`을 극대화하여 개발 생산성을 높이는 개발 모델 (*중요 용어: *소규모 릴리즈*, *스파이크*, *이터레이션*)
[^3]: 객체지향 방법론의 기본 원칙으로 '**캡슐화, 정보은닉, 추상화, 상속성, 다형성**'가 있다.
[^4]: Component Based Develoment
[^5]: 코드 검토(code review), 아키텍처 위험 분석(architectural risk analysis), 침투 테스트(penetration testing), 위험 기반 보안 테스트(risk-base security testing), 악용 사례(abuse cases), 보안 요구(security requirement), 보안 운영(security operation)
[^6]: **개념, 역할 기반, 활동 평가, 활동 구현, 취약성**의 5가지 관점에 따라 보안 절차 진행
[^7]: 입력 데이터 검증 및 표현, 보안 기능, 시간 및 상태, 에러 처리, 코드 오류, 캡슐화, API 오용


### 🔹Section 02. **소프트웨어 개발 방법론 테일러링 ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [ ] **PERT | CPM | LOC | COCOMO | CMM | SPICE**

✔ **방법론 테일러링**<br>
ㅤ: 개발 프로젝트의 특성 및 필요에 따라 기존의 소프트웨어 개발 모델을 **최적화**하는 활동<br><br>

✔ **프로젝트 일정 계획 방법론**<br>
ㅤ: 소요 기간의 예측 가능성에 따라 **PERT**, **CPM** 등으로 나눔<br>
ㅤ🔻 **PERT[^8]**: `작업별 개발 기간이 불확실`하여 개발 기간 내에 전체 프로젝트를 완료할 수 있을지에 대한 **확률을 분석**할 때 사용<br>
ㅤㅤㅤ❗중요 용어: *낙관치*, *기대치*, *비관치*, *예측치 = (낙관치 + (4 x 기대치) + 비관치) / 6* <br>
ㅤ🔻 **CPM[^9] (임계 경로 기법)**: `작업별 개발 기간이 확실`한 경우에 사용. <br>
ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ 계획된 최단시간으로 전체 프로젝트를 완료하기 위한 **주공정 경로,소요 기간 계산** <br>
ㅤㅤㅤ❗**임계 경로**: 작업 소요시간이 가장 오래 걸리는 경로 <br>
ㅤ🔻 **간트 차트(Gantt Chart)**: 프로젝트 개발 일정을 기능별로 시간에 흐름에 따라 막대 그래프를 사용하여 표현한 일정표<br><br>

✔ **소프트웨어 비용 산정**<br>
ㅤ: 소프트웨어 비용을 결정하는 요소는 **프로젝트**, **자원**, **생산성**이 있다.<br>
ㅤ🔶**하향식 비용 산정 기법** (과거의 유사한 개발 경험을 기반으로 비용을 산정하는 비과학적 기법)<br>
ㅤㅤㅤ**1️⃣** **전문가 측정 기법**: 2인 이상의 전문가들이 비용 산정<br>
ㅤㅤㅤ**2️⃣** **델파이(delphi) 측정 기법**: 조정자(Coordinator)가 여러 전문가의 의견을 종합하여 비용 산정 <br>
ㅤ🔶**상향식 비용 산정 기법** (세부적인 작업 단위별로 비용 산정 후 전체 비용 산정하는 방식)<br>
ㅤㅤㅤ**1️⃣** **LOC(Line Of Code) 기법**: 각 기능의 소스 코드 라인 수의 **비관치, 낙관치, 기대치**를 통해 **예측치**를 계산 및 비용 산정<br>
ㅤㅤㅤ**2️⃣** **단계별 노력(Effort Per Task) 기법**: 각 기능들을 구현시키는데에 `필요한 노력에 가중치`를 별도 반영하여 측정<br>
ㅤㅤㅤ**3️⃣** **수학적 산정 기법**<br>
ㅤㅤㅤㅤ- **COCOMO(COnstructive COst MOdel)**: Boehm(보임)이 제안한 LOC 기반 비용 산정 기법.<br>
ㅤㅤㅤㅤㅤ❗**Organic(조직형): 5만 라인 이하 / Semi-Detached(반분리형): 30만 라인 이하 / Embedded(내장형): 30만 라인 이상** <br>
ㅤㅤㅤㅤ- **Putnam(=생명 주기 예측 모형)**: Putnam이 제안. 대형 프로젝트의 노력 분포 산정에 이용. <br>
ㅤㅤㅤㅤㅤㅤㅤㅤ`시간에 따른 함수로 표현`되는 Ray-leigh-Norden 곡선의 노력 분포도에 기반<br>
ㅤㅤㅤㅤ- **기능 점수(Function Point)**: 알브레히트가 제안. S/W 기능을 증대시키는 요인별로 가중치를 부여하여 비용 산정<br><br>

✔ **소프트웨어 품질 관리**<br>
ㅤ🔻**CMM**(Capability Maturity Model): `S/W 개발 업체들의 업무 능력 평가` 기준을 세우기 위한 **평가 능력 성숙도 모델**<br> 
ㅤ🔻**CMMI**(Capability Maturity Model Integration): 3가지 CMM 모델[^10]을 통합하여 발전된 형태의 **CMM 국제 공인 기준**<br>
ㅤ🔻**SPICE[^11]**: S/W 품질 및 생산성 향상을 위한 **S/W 프로세스를 평가하는 국제 표준**. 0 → 5단계 <br> 
ㅤ🔻**CASE[^12] 도구**: S/W 개발 프로세스의 전 과정에서 `개발자의 반복적인 작업량을 줄이기` 위한 **자동화를 지원하는 S/W 도구**<br><br>

✔ **프로젝트 형상 관리**<br>
ㅤ: S/W 개발 프로젝트의 모든 과정에서 발생하는 산출물들의 종합 및 변경과정을 체계적으로 관리하고 유지하는 활동 및 기법.<br> 
ㅤㅤ이를 통해 변경 사항의 관리(reversion)가 가능<br>
ㅤㅤ❗형상 관리 프로세스: `'형상 식별 / 형상 통제 / 형상 상태 보고 / 형상 감사'` <br><br><br>

[^8]: Program Evaluation and Review Technique
[^9]: Critical Path Method
[^10]: SW-CMM(S/W 개발 및 유지보수 관련 성숙도 모델), SE-CMM(시스템 엔지니어링 능력 성숙도 모델), IPD-CMM(프로젝트 간 협동/통합 프로젝트 개선 모델)
[^11]: Software Process Improvement and Capability dEtermination
[^12]: Computer Aided Software Engineering


## 💠Chapter 02. 요구사항 확인
### 🔹Section 01. **소프트웨어 개발 환경 분석 ( ⭐ )**
> [!IMPORTANT]
> - [ ] **업무 파악 | 운영체제 | DBMS | 미들웨어 | 오픈 소스**

✔ **업무 파악** (현행 시스템 파악 절차)<br>

<div align="center">
  <img width="60%" src="https://private-user-images.githubusercontent.com/104110605/361131743-583abb75-ea77-4bfa-aaa7-74f8e0282c7a.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ0OTM1ODUsIm5iZiI6MTcyNDQ5MzI4NSwicGF0aCI6Ii8xMDQxMTA2MDUvMzYxMTMxNzQzLTU4M2FiYjc1LWVhNzctNGJmYS1hYWE3LTc0ZjhlMDI4MmM3YS5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQwODI0JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDgyNFQwOTU0NDVaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT00Y2Q5NmQ0NTA4MWJhY2FmNmE0YTE0MDliMWU5MzIyYTEyMzE1MGIzMTY4MWQ5YzE3MmQwOWNkMWFhYThjMjNlJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.Ac72YUktRSIo5O501R4I8x9LRmNeufbHcRwZfUzm-gg">
</div> <br>


✔ **운영체제** (현행 시스템 파악 절차)<br>
ㅤ: 사용자가 손쉽고 효율적으로 컴퓨터 시스템을 사용하도록 돕는 소프트웨어. H/W와 S/W 리소스 관리, 컴퓨터 프로그램을 위한 공통 서비스를 제공<br>
ㅤㅤex) Microsoft Windows, UNIX, Linux, iOS, Android<br>

✔ **DBMS(DataBase Management System)** <br>
ㅤ: `사용자, 애플리케이션, 데이터베이스와 상호 작용`하여 **데이터를 저장, 관리, 상호작용하는 시스템**<br>
ㅤㅤex) Oracle, MSSQL, MySQL, MongoDB<br>

✔ **미들웨어(Middleware)** <br>
ㅤ: `운영체제와 소프트웨어 애플리케이션 사이`에 위치하여 **운영체제가 제공하는 서비스를 확장하여 제공하는 소프트웨어**<br>

✔ **오픈 소스(Open Source)** <br>
ㅤ: 소스 코드를 무료로 공개하여 제한 없이 누구나 사용 및 제작이 가능한 소프트웨어<br><br><br>

### 🔹Section 02. **요구사항 확인 ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [ ] **요구사항 도출 | 유스케이스(Use Case) 다이어그램 | 기능/비기능적 요구사항 | 구조적 분석 도구**

✔ **요구사항 도출 기법**<br>
ㅤ: 사용자 요구사항은 불명확하고 변할 수 있기 때문에 다양한 도출 기법을 사용해야 함<br>
ㅤㅤex) 인터뷰, 설문, 사용자 스토리, 업무절차 조사, 브레인 스토밍 회의, 프로토타이핑, 유스케이스[^13] <br>

✔ **유스케이스(Use Case) 다이어그램**<br>
ㅤ:사용자와 다른 외부 시스템들이 목표 시스템을 이용하여 수행하는 **기능**을 `사용자의 관점`에서 표현한 **도표** <br>
ㅤ❗구성요소: **시스템 범위(Scope), 액터(actor / 주: 사용자, 부: 시스템), 유스케이스, 관계** <br>

✔ **요구사항 분류(Requirement Classification)** <br> 
ㅤ🔻**기능적 요구사항**: **시스템의 기능, 제어 연산, 기술에 대한 요구사항** <br>
ㅤ🔻**비기능적 요구사항**: **성능, 보안, 품질, 안전 등에 대한 요구사항** <br>

✔ **구조적 분석 도구** <br> 
ㅤ🔻**자료 흐름도(DFD; Data Flow Diagram)**: `기능에 의한 데이터의 흐름`을 **도형으로 표현**한 도표[^14].  <br>
ㅤ🔻**자료 사전(DD; Data Dictionary)**: 자료 흐름도(DFD)에 사용된 데이터의 `이름과 속성`을 표기한 **자료(Meta Data[^15])** <br>
ㅤ🔻NS(Nassu-Schneiderman) 차트: `문제 처리 프로세스`를 도형을 통해 논리 중심으로 표현한 차트 <br>
ㅤ🔻**HIPO**(Hierarchy Input Process Output): 기능과 데이터의 관계를 `여러 개의 고유 모듈로 분할`하여 **계층적[^16]으로 표현**한 도표 <br>

✔ **요구사항 검증 기법** <br> 
ㅤ🔻**요구사항 검토(Review)**: 요구사항 검토 담당자들이 직접 요구사항 명세서 검증하는 방식 <br>
ㅤㅤㅤ**1️⃣** **동료(Peer) 검토**: 요구사항 명세서 **작성자가 다수의 동료들에게 직접 설명**하며 결함 분석 <br>
ㅤㅤㅤ**2️⃣** **워크스루(Walk Through)**: 미리 요구사항 명세서를 배포하여 **사전 검토 후 짧은 회의**를 통해 결함 분석 <br>
ㅤㅤㅤ**3️⃣** **인스펙션(Inspection)**: 요구사항 명세서 작성자 이외의 **전문 검토 그룹**이 상세히 결함 분석 <br>
ㅤ🔻**프로토타이핑**: 요구사항 검증을 위한 시제품 간단하게 개발하여 검증<br>
ㅤ🔻**모델 검증**: 요구사항 분석 단계에서 개발된 모델이 요구사항을 만족하는 지 검증하는 방법<br>
ㅤ🔻**인수(Acceptance) 테스트**: 개발이 완료된 소프트웨어를 직접 인수받아 인수자가 직접 테스트하여 요구사항 만족 여부를 검사<br><br><br>

[^13]: 사용자 요구사항을 시스템 이용자와 기능, 관계로 표현
[^14]: **단말: 데이터 입출력 주체(사각형) / 프로세스: 데이터 처리 과정(타원) / 자료 흐름: 데이터 흐름 방향(화살표) / 자료 저장소: 데이터 저장 위치(상하 평행선)**
[^15]: **데이터의 정의 및 설명 등을 위해 사용하는 데이터**. `정의(=) / 연결(+) / 선택([ ] | [ ]) / 반복({ }) / 생략(( )) / 주석(* *)`
[^16]: 가시적 도표(Visual Table of Contents), 총체적 도표(Overview Diagram), 세부적 도표(Detail Diagram)로 나눔

### 🔹Section 03. **UML ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [ ] **사물(Thing) | 다이어그램(Diagram) | 관계(Relation)**

✔ **UML(Unified Modeling Language)** <br>
ㅤ: **개발자 간의 원화한 의사소통**을 위해 소프트웨어 공학에서 사용되는 **표준화된 범용 모델링 언어** <br>

✔ **사물(Thing)** <br>
ㅤ: **다이어그램 안에서 관계가 형성될 수 있는 대상** <br>
ㅤ🔻 **구조 사물**:  **개념적, 물리적 요소** (Class, Interface, Usecase, Node ...) <br>
ㅤ🔻 **그룹 사물**: **UML 요소들의 그룹화** <br>
ㅤ🔻 **주해 사물**: UML에 대한 **부가적 설명, 주석** <br>
ㅤ🔻 **행동 사물**: 각 요소들의 **행위, 상호작용** <br>

✔ **다이어그램(Diagram)** <br>
ㅤ: **사물과의 관계를 정형화된 도형으로 표현하여 의사소통에 도움을 주는 도구** <br>
ㅤ🔻 **구조적(Structural) 다이어그램 (정적)** <br>
ㅤㅤㅤ**1️⃣** **클래스(Class) 다이어그램**: 클래스 간의 구조적인 관계 표현. **클래스명, 속성, 연산, 접근 제어자[^17]** 등으로 구성<br>
ㅤㅤㅤ**2️⃣** **객체(Object) 다이어그램**: 클래스의 인스턴스를 객체 간의 관계로 표현<br>
ㅤㅤㅤ**3️⃣** 컴포넌트(Component) 다이어그램: 구현 단계에서 사용. 컴포넌트 간의 구성과 연결 상태 표현<br>
ㅤㅤㅤ**4️⃣** 배치(Deployment) 다이어그램: 구현 단계에서 사용. 노드, 컴포넌트 등의 물리적인 아키텍처 표현 <br>
ㅤㅤㅤ**5️⃣** 복합체 구조(Composite Structure) 다이어그램: 복합적인 구조를 갖는 컴포넌트, 클래스 등의 내부 구조 표현<br>
ㅤㅤㅤ**6️⃣** 패키지(Package) 다이어그램: 같은 그룹의 하위 모듈들을 묶어주는 패키지 간의 의존 관계 표현 <br>

ㅤ🔻 **행위적(Behavioral) 다이어그램 (동적)** <br>
ㅤㅤㅤ**1️⃣** **유스케이스(Use case) 다이어그램**: **사용자의 요구사항을 분석하여 기능을 중심으로 모델링한 결과물**을 표현 <br>
ㅤㅤㅤ**2️⃣** **시퀀스(Sequence) 다이어그램**: **객체들의 생성과 소멸, 객체들이 주고받는 메시지** 표현 <br>
ㅤㅤㅤ**3️⃣** 통신(Communication) 다이어그램: 시퀀스 다이어그램 + 객체들의 연관 관계 표현<br>
ㅤㅤㅤ**4️⃣** 상태(State) 다이어그램: 한 객체의 이벤트 활성에 따른 상태 변화 표현<br>
ㅤㅤㅤ**5️⃣** 활동(Activity) 다이어그램: 객체의 프로세스나 로직의 처리 흐름을 순서에 따라 표현<br>
ㅤㅤㅤ**6️⃣** 상호작용(Interaction Overview) 다이어그램: 통신, 시퀀스, 타이밍 등의 다이어그램 사이의 제어 흐름 표현<br>
ㅤㅤㅤ**7️⃣** 타이밍(Timing) 다이어그램: 객체의 상태 변화와 시간 제약을 명시적으로 표현<br>

✔ **관계(Relation)**<br>
ㅤ: **사물과 사물의 연관성을 표현한 것** <br>
ㅤ🔻 **연관(Association)**: **특정 사물**이 **다른 사물의 특성**을 지속적으로 **참조** `ex. [고객]ㅡ'대여하다'ㅡ[도서]` <br>
ㅤ🔻 **집합(Aggregation)**: **사물(Part)이 다른 사물(Whole)에 포함**. 전체와 부분은 서로 **독립적** `ex. 컴퓨터 ◇ㅡ 마우스` <br>
ㅤ🔻 **포함(Composition)**: **사물(Part)이 다른 사물(Whole)에 포함**. 전체와 부분은 서로 **종속적** `ex. 마우스 ◆ㅡ 마우스 리시버` <br>
ㅤ🔻 **일반화(Generalization)**: 하나의 사물이 다른 사물에 대해 **상/하위 관계**. `ex. 입력장치 ◁-- (마우스, 키보드, 마이크)` <br>
ㅤ🔻 **의존(Dependency)**: **필요에 의해(조건에 따라)** 짧은 시간 동안만 관계를 유지 `ex. 고객 --> 사은품`<br>
ㅤ🔻 **실체화(Realization)**: **사물들의 공통적인 기능**을 상위 사물로 그룹화하여 표현 `ex. 정보제공 ◁-- (도서, 강사, 컴퓨터)` <br><br>

✔ **스테레오 타입(Stereo type)**<br>
ㅤ: UML의 기본적 요소 이외에 **새로운 요소를 만들어내는 확장 구조**들 중 하나. `<< >>` 기호 사용하여 표현 <br><br><br>

[^17]: public(+): **클래스 외부에서도 접근 허용 / private(-): 클래스 내부에서만 접근 허용 / default(~): 동일 패키지 클래스에서의 접근만 허용 / protected(#): 하위 클래스에서의 접근만 허용**


## 💠Chapter 03. 화면 설계
### 🔹Section 01. **UI 요구사항 ( ⭐ )**
> [!IMPORTANT]
> - [ ] **UI 구성 요소 | UI 정의 | 웹 콘텐츠 접근성 | UI 프로토타입**

✔ **UI(User Interface)**<br>
ㅤ: **사용자와 컴퓨터 상호 간의 원활한 소통을 도와주는 연계 시스템**. **CLI, GUI, NUI** 등이 있다. <br>

✔ **UI element 종류**<br>
ㅤ: **텍스트(Text) 박스, 라디오(Radio) 버튼, 토글(Toggle) 버튼, 콤보(Combo) 박스, 체크(Check) 박스, 명령(Command) 버튼** 등이 있다. <br>

<div align="center">
  <img width="50%" src="https://private-user-images.githubusercontent.com/104110605/361435212-4726c4de-e094-433d-8d48-4e9aa790d23b.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ2NzY0NjgsIm5iZiI6MTcyNDY3NjE2OCwicGF0aCI6Ii8xMDQxMTA2MDUvMzYxNDM1MjEyLTQ3MjZjNGRlLWUwOTQtNDMzZC04ZDQ4LTRlOWFhNzkwZDIzYi5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQwODI2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDgyNlQxMjQyNDhaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1mYzVhZGVhZjZmMDdiMzZhMzg3OWJkMTNhMDBlNzM5ZGYwZGIyYjJhNmRlYjk2MDdkY2E2Nzc3NTAxMzI3NDE0JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.0tp7vr49PGfZFAXj-V7_GKbM3R4a_6kRD9DTMGMrNVY">
</div> <br>

✔ **웹 콘텐츠 접근성(Web Content Accessibility)**<br>
ㅤ: 콘텐츠를 제공할 때, 디지털 약자를 위한 대체 형식의 콘텐츠를 함께 제공하는 것. 한국형 웹 콘텐츠 정의성 지침(Korea WCA Guideline)<br>

✔ **UI 프로토타입**<br>
ㅤ: UI에 대한 사용자 요구사항을 검증하기 위해 최대한 단순하게 제작한 시제품. Paper Prototype과 Digital Prototype이 있다.<br><br><br>

### 🔹Section 02. **UI 설계 ( ⭐ )**
> [!IMPORTANT]
> - [ ] **UI 설계 원칙 | UI 설계 도구 | HCI | UX**

✔ **UI 설계 원칙**<br>
ㅤ: 직관성(쉽게 이해), 유효성(정확하게 전달), 학습성(쉽게 배움), 유연성 등이 있다. <br>

✔ **UI 설계 도구**<br>
ㅤ🔻 **와이어프레임**: 페이지에 대한 **대략적인 뼈대나 레이아웃만 설계**하여 나타냄<br>
ㅤ🔻 **목업**: **실제 화면과 유사한 형태로 제작한 정적인(기능을 반영하지 않은) 모델**<br>
ㅤ🔻 **스토리보드**: 와이어프레임 + **콘텐츠에 대한 설명** + **화면 간 이동 흐름**을 추가한 **문서** <br>
ㅤ🔻 **프로토타입**: **특정 기능만을 간단하게 구현**하여 **테스트 및 피드백이 가능한 모델**<br>
ㅤ🔻 **유스케이스**: 요구사항을 빠르게 파악하기 위해 **사용자의 요구사항을 기능 단위로 표현한 모델**<br>

✔ **HCI(Human Computer Interface)**<br>
ㅤ: 인간과 시스템의 상호작용이 보다 편리하고 안전하도록 연구하는 학문 <br>

✔ **UX(User eXperience)** <br> 
ㅤ: **사용자가 시스템을 이용하면서 느끼게 되는 종합적인 경험** **※ UI는 사용성과 편의성을 중시, UX는 이를 통해 느끼게 되는 만족감을 중시** <br><br><br>

## 💠Chapter 04. 애플리케이션 설계
### 🔹Section 01. **공통 모듈 설계 ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [ ] **재공학(Re-Engineering) | 응집도(Cohesion) | 결합도(Coupling) | 공유도(Fan-In) | 제어도(Fan-Out)**

✔ **모듈화**<br>
ㅤ: 프로그램이 효율적으로 관리될 수 있도록 시스템을 분해하고 추상화하는 기법 <br>

✔ **소프트웨어 재공학(Re-Engineering)** <br>
ㅤ: 기존의 시스템을 이용하여 보다 나은 시스템을 구축하는 방법 <br>
ㅤ🔻 **분석(Analysis)**: 기존 소프트웨어의 명세를 통해 소프트웨어를 **분석하고 재공학 대상을 식별하여 재공학의 가치를 판단** <br>
ㅤ🔻 **재구성(Restructuring)**: 소프트웨어의 **기능이나 외적인 동작은 변형하지 않으면서 소프트웨어의 코드를 재구성하여 내부 구조와 품질을 향상** <br>
ㅤ🔻 **역공학(Reverse Engineering)**: 외계인 코드(Alien Code)로부터 소프트웨어의 **소스 코드를 복구**하여 **설계 정보와 데이터 구조 정보 등을 추출** <br>
ㅤ🔻 **이식(Migration)**: 기존 소프트웨어의 구조 및 기능을 **다른 플랫폼에서 사용할 수 있도록 변환**하는 것 <br>

✔ **모듈 응집도(Cohension)** <br>
ㅤ: 모듈의 내부 요소들의 관계가 얼마나 밀접한지를 나타내는 정도 <br>
ㅤ❗小 **| 우연 < 논리 < 시간 < 절차 < 통신 < 순차 < 기능 |** 大  <br>


✔ **모듈 결합도(Coupling)** <br>
ㅤ: 모듈과 모듈 간의 관련성이 얼마나 깊은지를 나타내는 정도 <br>
ㅤ❗小 **| 내용(Content) < 공통(Common) < 외부(External) < 제어(Control) < 스탬프(Stamp) < 자료(Data) |** 大 <br>

✔  **복잡도** <br>
ㅤ🔻 **공유도(Fan-In)**: **자신을 호출(공유)하는 모듈의 수** <br>
ㅤ🔻 **제어도(Fan-Out)**: **자신이 호출(제어)하는 모듈의 수** <br>
ㅤ✅ **공유도와 응집도는 높게, 제어도와 결합도는 낮게**할 수록 **모듈의 독립성이 높아**진다. <br><br><br>


### 🔹Section 02. **시스템 연동 설계 ( ⭐⭐ )**
> [!IMPORTANT]
> - [ ] **코드 설계 | 소프트웨어 아키텍처 | 미드웨어 솔루션 | 재해 복구**

✔  **코드(Code)** <br>
ㅤ: **순차(Sequence) 코드, 블록(Block) 코드, 10진(Decimal) 코드, 그룹 분류(Group Classification) 코드, 연상(Mnemonic) 코드, 표의(Significant Digit) 코드, 합성(Combined) 코드** <br>

✔  **시스템 연동** <br>
ㅤ🔻 **인터페이스 연동**: API(Application Program Interface), RMI(Remote Method Invocation) 등을 통해서 다른 시스템과 연계하여 업무를 수행하는 체계<br>
ㅤ🔻 **웹 서비스 연동** <br>
ㅤㅤ**1️⃣** **SOAP(Simple Object Access Protocol)**: 이기종 시스템의 데이터, 서비스 호출을 위한 XML 기반의 통신규약<br>
ㅤㅤ**2️⃣** **UDDI(Universal Description Discovery Integration)**: 간편한 웹 서비스 검색을 위한 XML 기반의 통합 레지스트리<br>
ㅤㅤ**3️⃣** **WSDL(Web Service Description Language)**: 웹 서비스를 기술하기 위한 XML 기반 표준 언어<br>

✔  **소프트웨어 아키텍처** <br>
ㅤ: **소프트웨어의 기본 구조를 정의한 것**. 소프트웨어 설계 및 구현을 위한 틀 제공 <br>
ㅤ🔻**계층화(Layered) 패턴**: 논리적인 레이어(계층 구조)로 분리하여 서로 인접한 레이어끼리만 상호작용하는 패턴. 시스템을 물리적으로 분리하는 n-Tier(1~3)과 서비스 지향 아키텍처(SOA)패턴  <br>
ㅤ🔻**클라이언트/서버(Client/Server) 패턴**: `서비스를 제공`하는 **하나의 서버**와 `서비스를 요청`하는 **다수의 클라이언트**로 구성<br>
ㅤ🔻**마스터/슬레이브(Master/Slave) 패턴**: `작업을 분리하고 배포`하는 **마스터**와 `요청한 작업을 처리`하는 **다수의 슬레이브**로 구성<br>
ㅤ🔻**파이프-필터(Pipe-Filter) 패턴**: `서브 시스템(Filter)에 입력된 데이터를 처리한 결과`를 **파이프를 통해 다음 서브 시스템으로 전달**<br>
ㅤ🔻**브로커 패턴(Broker)**: `다수의 서버와 다수의 클라이언트 사이`에 **브로커**를 두고 클라이언트의 요청을 브로커가 판단하여 적절한 서버에게 전달하는 방식 (= **중계서버**) <br>
ㅤ🔻**피어-투-피어(Peer-To-Peer) 패턴**: 각 **컴포넌트**가 `서버와 클라이언트의 역할`을 **유동적으로 바꾸어가며** 서비스를 요청하고 제공<br>
ㅤ🔻**이벤트-버스(Event-Bus) 패턴**: `데이터와 처리 결과를 특정 채널에 전달`하고, 이 채널을 **구독하고 있는 리스너**는 `전달된 메시지에 대해 알림을 수신` <br>
ㅤ🔻**MVC(Model, View, Controller) 패턴**: 데이터[^18]와 시각화 요소[^19], 상호작용[^20]을 서로 분리하여 UI 변경에 다른 업무 로직이 받는 영향을 최소한 패턴 <br>
ㅤ🔻블랙보드(Blackboard) 패턴: **비결정성 알고리즘**(결과가 정해지지 않은 해결 전략)을 구현하는 패턴 <br>
ㅤ🔻인터프리터(Interpreter) 패턴: `특정 언어 및 명령어로 작성된 프로그램`을 **해석하는 컴포넌트 설계에 적용**되는 패턴 <br>

[^18]: Model - 응용 프로그램의 **데이터 처리 담당**
[^19]: view - 모델의 **데이터 시각화 담당(UI)**
[^20]: Controller - 모델과 **업무 로직의 상호작용 담당**

✔  **미드웨어 종류별 특징** <br>
ㅤ🔻**DBMS(DataBase Management System)**: `Vendor(DB 제공 업체)`에서 제공하는 **클라이언트에서 DB와 연결**하기 위한 미들웨어 <br>
ㅤ🔻**RPC(Remote Procedure Call)**: `응용 프로그램의 프로시저`를 사용하여 **원격에서 동작하는 프로시저[^21]를 로컬 프로시저를 로컬 프로시저처럼 호출**하기 위한 미들웨어 <br>
ㅤ🔻**MOM(Message Oriented Middleware)**: **메시지 기반의 비동기형 메시지를 전달**하는 방식의 미들웨어. 서로 다른 기종의 분산 데이터 시스템의 동기화를 위해 사용 <br>
ㅤ🔻**TP-Monitor(Transaction Processing Monitor)**: **온라인 트랜잭션 업무**(은행, 예매, 예약 등)를 **처리하고 감시 및 제어**하는 미들웨어 <br>
ㅤ🔻ORB(Object Request Broker): 코바(CORBA[^22]) 표준 규격을 구현한 객체지향 미들웨어 <br>
ㅤ🔻**WAS(Web Application Server)**: HTTP 세션 처리를 위한 웹 환경을 구현하기 위한 미들웨어 <br>

[^21]: (= 루틴, 함수), 한 개 이상의 기능을 수행하기 위한 명령문의 집합
[^22]: Common Object Request Broker Architecture. 객체 관리 그룹(OMG)에서 정의한 분산 컴퓨팅과 객체지향 기술을 통합한 표준 아키텍쳐

✔  **코드 오류** <br>
ㅤ🔻**생략(Omission) 오류**: **한 자리가 누락**된 경우 <br>
ㅤ🔻**필사(Transcription) 오류**: **한 자리가 잘못 입력**된 경우 <br>
ㅤ🔻**전위(Transposition) 오류**: **좌우 자리가 바뀌어 입력**된 경우 <br>
ㅤ🔻**이중(Double) 전위 오류**: **전위 오류가 둘 이상 발생**한 경우 <br>
ㅤ🔻**추가(Addition) 오류**: **한 자리가 추가 입력**된 경우 <br>
ㅤ🔻**임의(Random) 오류**: **여러 오류가 둘 이상 결합**된 경우 <br>

✔  **오류 대응방안** <br>
ㅤ🔻**이중화**: **복수의 시스템을 활용**하여 `주 시스템에 장애가 발생한 경우에도 정상적인 서비스가 제공`될 수 있도록 하는 기술 ex. Active-Active, Active-StandBy <br>
ㅤ🔻**재해 복구 시스템(DRS[^23])**: 원활한 재해 복구 수행을 지원하기 위한 시스템. 업무 연속성의 유지를 위한 체계 <br>
ㅤㅤㅤ**1️⃣** Mirror Site: 주 시스템과 **동일**한 수준의 시스템을 복구 센터에 구축하여 **동시 서비스** <br>
ㅤㅤㅤ**2️⃣** Hot Site: 주 시스템과 **동일**한 수준의 시스템을 복구 센터에 구축하여 **대기 상태 유지** <br>
ㅤㅤㅤ**3️⃣** Warm Site: **중요성이 높은 정보 자원**만 복구 센터에 **보관** <br>
ㅤㅤㅤ**4️⃣** Cold Site: **최소한의 기술 자원**(공간, 전기, 냉방, 습도관리 등)만 복구 센터에 확보 <br>        
ㅤㅤㅤㅤ❗**RTO**(Recovery Time Objective): 중단된 서비스를 복구하기 위해 주 시스템에 허용되는 **최대 허용 중단 시간** <br>
ㅤㅤㅤㅤ❗**RPO**(Recovery point Objective): 서비스 중단 시점과 마지막 복구 시점 사이에 허용되는 **데이터 손실량** <br>
ㅤㅤㅤㅤ❗**BIA**(Business Impact Analysis): 재해나 장애로 인해 서비스의 문제가 발생한다는 가정하에 이에 따른 영향도 및 손실 평가를 조사 <br><br><br>

[^23]: Disaster Recovery System

## 💠Chapter 05. 인터페이스 설계
### 🔹Section 01. **인터페이스 설계 ( ⭐ )**
> [!IMPORTANT]
> - [ ] **인터페이스 | 시스템 연계 기술 | 필수 암호화 항목**

✔  **인터페이스(Interface)** <br>
ㅤ: **서로 다른 시스템 및 사용자 사이에서 정보를 주고받는 물리적, 논리적 매개체**. 상호작용 대상에 따라 `시스템 인터페이스`, `사용자 인터페이스`로 나뉜다. <br>

✔  **시스템 연계 기술** <br>
ㅤ🔻**DB Link**: **DB에서 제공하는 DB Link 객체를 이용하는 기술**. 수신 시스템에서 DB Link를 생성하고 송신 시스템에서 해당 DB Link를 직접 참조하는 방식.<br>
ㅤ🔻**DB Connection**: 수신 시스템의 WAS에서 송신 시스템 DB로 연결하는 DB Connection Pool을 생성하고 연계 프로그램에서 해당 DB Connection Pool을 이용하는 기술<br>
ㅤ🔻**API**: **송신 시스템의 DB에서 데이터**를 읽어와서 제공하는 **애플리케이션 프로그래밍 인터페이스 프로그램** <br>
ㅤ🔻**JDBC(Java DataBase Connectivity)**: **수신 시스템의 프로그램**에서 JDBC 드라이버를 이용하여 **송신 시스템 DB와 연결**하는 기능 <br>
ㅤ🔻**Hyper Link**: **웹 애플리케이션**에서 하이퍼링크를 이용하는 기술 <br>
ㅤ🔻**Sorket**: 서버는 **통신을 위한 소켓을 생성하여 포트를 할당**하고 클라이언트의 통신 요청 시 **클라이언트와 연결하고 통신**하는 네트워크 기술 <br>
ㅤ🔻**Web Service**: WSDL, UDDI, SOAP 프로토콜을 이용하여 연계하는 기술 <br><br><br>

----------------------------------------------------------------------------------------------------------------------------

# ✳️ 과목 2. 소프트웨어 개발
## 💠Chapter 01. 자료 구조
### 🔹Section 01. **자료 구조 ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [ ] **선형/비선형 | 수식 표현법 | 연결 리스트 | 트리 순회**

✔  **자료 구조** <br>
ㅤ: 프로그램에서 쉽게 활용될 수 있도록 논리적으로 설계된 데이터 구조 및 관계<br>
ㅤ🔻**단순 구조**: 프로그래밍 언어에서 제공하는 **기본 데이터 타입을 사용하는 구조**. <br>
ㅤㅤㅤ`ex. 정수, 실수, 문자 등의 데이터` <br>
ㅤ🔻**선형 구조**: 데이터들의 **대응 관계가 1:1로 구성**되는 구조. **순차 구조(Sequential)와 연결 구조(Linked)** 로 구분 <br> 
ㅤㅤㅤ`ex. 스택(Stack), 큐(Queue), 덱(Deque), 선형(Linear) 리스트, 연결(Linked) 리스트 등` <br>
ㅤ🔻**비선형 구조**: 데이터들의 **대응 관계가 1:N, N:M 등으로 구성**되는 구조. <br>
ㅤㅤㅤ`ex. 트리(Tree), 그래프(Graph)` <br>

✔  **알고리즘(Algorithm)** <br>
ㅤ: 문제를 해결하기 위해 수행해야 하는 기능들의 효율적인 해법. 표현 방법으로는 **순서도(Flow Chart)** 와 **의사코드(Pseudo Code)** 가 있다. <br>
ㅤ🔻**동적 계획법(Dynamic Programming)**: **작은 문제의 해(풀이)를 활용하여 큰 문제의 해**를 찾는 방식(Bottom-up) <br>
ㅤ🔻**탐욕(Greedy) 알고리즘**: **분기마다 가장 최적의 해를 선택**하여 결과를 도출하는 방식 <br>
ㅤ🔻**재귀(Recursive) 알고리즘**: 풀이 도중 **같은 풀이를 다시 불러오는 과정을 반복**하는 방식 <br>
ㅤ🔻**근사(Approximation) 알고리즘**: 최적의 답을 구할수 없어도 **비교적 빠른 시간에 계산이 가능한 근사 해법을 수행**하는 알고리즘 <br>
ㅤ🔻**분할 정복법(Divide and Conquer)**: **크고 방대한 문제를 효율적으로 풀 수 있는 단위로 작게 나누는 방식**(계산된 결과를 다시 합쳐서 큰 문제 해결. Top-down)<br>
ㅤ🔻**퇴각 검색법(Backtracking)**: 분기구조 탐색에서 탐색에 실패하는 경우, **탐색이 성공했던 이전 분기로 되돌아가는 방식**<br>

✔  **선형 구조** <br>
ㅤ**1️⃣** **스택(Stack)**: 가장 나중에 삽입된 데이터가 가장 나중에 추출되는 **후입선출(LIFO)** 방식. <br>
ㅤㅤ❗ **Overflow / Underflow**: 데이터 **삽입 / 추출** 중, 스택의 크기를 넘어서게 될 때 오류<br>
ㅤㅤ❗ **수식표기법**: 연산자의 위치에 따라 **전위식(Pre-fix), 중위식(In-fix), 후위식(Post-fix)** 으로 나뉜다. <br>
ㅤ**2️⃣** **큐(Queue)**: 가장 먼저 삽입된 데이터가 가장 먼저 출력되는 **선입선출(FIFO)** 방식. 포인터의 초기값은 모두 `-1` <br>
ㅤ**3️⃣** **덱(Deque)**: 데이터의 **입출력이 양쪽 모두**에서 일어나는 구조(양방향 큐). <br>
ㅤㅤㅤ입출력 제한 유형에 따라 **스크롤 방식(Scroll; 입력 제한)** 과 **쉘프 방식(Shelf; 출력 제한)** 이 있다.<br>
ㅤ**4️⃣** **선형(Linear) 리스트**: 가장 단순한 구조로 **탐색 속도가 빠름**. <br>
ㅤㅤㅤ삽입 및 삭제 시 나머지 **데이터들의 위치 이동이 필요**하므로 시간이 오래 걸림<br>
ㅤ**5️⃣** **연결(Linked) 리스트**: 데이터의 연속적 나열이 아닌, **서로 다른 위치의 노드와 노드의 연결로 구성** <br> 
ㅤㅤㅤㅤㅤ`ex. 단일 원형 연결 리스트, 이중 연결 리스트, 이중 원형 연결 리스트` <br>

✔  **비선형 구조** <br>
ㅤ**1️⃣** **트리(Tree)**: **데이터를 1:N의 계층 구조로 표현**하는 자료 구조<br>

<div align="center">
  <img width="30%" src="https://i.namu.wiki/i/8pViDtKiYxEmcz1zj2WHZEpLHeu4q4n1bAjOOTvA4rLde3d-miR4lbCeFRjhzuTV1SLW5vFdg81Q6vb6fm1I9Q.webp">
  <img width="65%" src="https://mblogthumb-phinf.pstatic.net/MjAxNzAxMDFfMTk3/MDAxNDgzMjU0NTMxODEx.1M3e4qVK8g1TBZOo933rziW5ljK53miyviv2S7YJPc8g.t-Sslx5_AuldP00f8kD0TkBZvN7cnmeQ-Yfy9L5l7F8g.JPEG.occidere/image_9931530701483254477493.jpg?type=w800">
</div>
<br>

ㅤ**2️⃣** **그래프(Graph)**: **노드를 N:M의 계층 구조로 표현**하는 자료 구조<br>
ㅤㅤ🔻**정점(Vertex)**: 트리의 Node와 같은 개념 <br>
ㅤㅤ🔻**간선(Edge, Branch)**: 정점을 연결하는 선 <br>
ㅤㅤ🔻**인접 정점(Adjacent Vertex)**: 간선에 의해 직접 연결된 정점 <br>
ㅤㅤ🔻**사이클(Cycle)**: 시작과 종료의 정점이 동일한 경우 <br>
ㅤㅤ🔻**단순 경로(Simple Path)**: 반복되는 정점이 없는 경로 <br><br><br>

### 🔹Section 02. **탐색 - Search ( ⭐⭐ )**
> [!IMPORTANT]
> - [ ] **탐색의 종류 | 시간 복잡 | 해시 함수**

✔  **탐색(Search)** 의 종류 <br>
ㅤ🔻**선형 탐색**: 대상 데이터를 **처음부터 순차적으로 비교**하여 검색. `O(N)` <br>
ㅤ🔻**이분 탐색**: 대상 데이터를 **절반씩 나눠가며** 검색 `O(log n)`<br>
ㅤ🔻**보간 탐색**: 찾을 값의 **위치값을 예상**하여 검색하는 사전식 탐색 `O(log(logN))`<br>
ㅤ🔻**블록 탐색**: 대량의 데이터를 **그룹별로 블록화하여 인덱싱**을 통해 검색 `O(N)`<br>
ㅤ🔻**이진 트리 탐색**: 검색 대상 데이터를 **이진 트리로 변형**한 뒤에 검색 `O(logN)`<br>
ㅤ🔻**해싱 탐색**: **해싱 함수[^24]를 사용**하여 데이터 검색 `O(1)`<br>

[^24]: 연산의 방식에 따라 **재산법(Division), 폴딩법(Folding), 제곱법(Square), 숫자분석법(Digit Analysis), 기수변환법(Radix Conversion), 무작위법(Random)** 등으로 나눔

> [!TIP]
> [참고 자료] (https://velog.io/@stresszero/search-bst)

✔  **복잡도** <br>
ㅤ**1️⃣** **공간 복잡도**: 알고리즘 연산 수행동안 **사용되는 메모리 공간의 크기**. 알고리즘 품질에 미치는 영향은 작음<br>
ㅤ**2️⃣** **시간 복잡도**: 알고리즘으로 인해 **연산이 수행되는 횟수**. 최악의 경우를 기준으로 산출 <br>
ㅤㅤ❗ **빅 오(O) 표기법** <br>
ㅤㅤㅤ🔻 **O(1)**: 입력 데이터 수와 관계없이 **일정한 수행 횟수**를 가지는 시간 복잡도 <br>
ㅤㅤㅤ🔻 **O(log N)**: 입력 데이터 수에 따라 **연산 횟수가 늘어나는 폭이 점점 줄어드는** 시간 복잡도<br> 
ㅤㅤㅤㅤㅤ`ex. 이분 탐색, 이진 트리 탐색` <br>
ㅤㅤㅤ🔻 **O(N)**: 입력 데이터 수에 따라 **연산 횟수가 비례하여 증가**하는 시간 복잡도 <br>
ㅤㅤㅤㅤㅤ`ex. 순차 탐색, 수열 계산`<br>
ㅤㅤㅤ🔻 **O(Nlog N)**: 입력 데이터 수에 따라 **연산 횟수가 늘어나는 폭이 점점 커지는** 시간 복잡도 <br>
ㅤㅤㅤㅤㅤ`ex. 퀵 정렬, 힙 정렬, 병합 정렬` <br>
ㅤㅤㅤ🔻 **O(N^2)**: 입력 데이터 수에 따라 연산 횟수가 **데이터 수의 제곱만큼 필요한** 시간 복잡도 <br>
ㅤㅤㅤㅤㅤ`ex. 선택 정렬, 버블 정렬`<br>
ㅤㅤㅤ🔻 **O(2^N )**: 입력 데이터 수에 따라 연산 횟수가 **데이터 수의 지수승만큼 필요한** 시간 복잡도 <br>
ㅤㅤㅤㅤㅤ`ex. 재귀 호출`<br>
ㅤㅤㅤ🔻 **O(N!)**: 입력 데이터 수에 따라 연산 횟수가 **데이터 수의 팩토리얼만큼 필요한** 시간 복잡도 <br>

<div align="center">
  <img width="45%" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbvSKij%2FbtrCmflIZCF%2FgRGJGS5rNLxNqYxZMCIk8K%2Fimg.png">
</div> <br>


### 🔹Section 03. **정렬 - Sorting ( ⭐⭐ )**
> [!IMPORTANT]
> - [x] **선택 정렬 | 버블 정렬 | 삽입 정렬**

✔  **정렬(Sorting)** 의 종류 <br>
<div align="center">
  
|**정렬 방식**|**평균**|**최악**|
|:--:|:--:|:--:|
|**삽입 정렬**| O(N^2)|O(N^2)|
|**버블 정렬**|O(N^2)|O(N^2)|
|**선택 정렬**|O(N^2)|O(N^2)|
|쉘 정렬|O(N^1.5)|O(N^1.5)|
|**힙 정렬**|O(NlogN)|O(NlogN)|
|이진 병합 정렬|O(NlogN)|O(NlogN)|
|퀵 정렬|O(NlogN)|O(N^2)|
|버킷 정렬|O(D+N)|O(N^2)|
</div> <br>

ㅤ🔻**선택(Selection) 정렬**: 정렬 대상 중 **기준값으로 선택된 데이터**와 **나머지 데이터들의 최소값을 비교**하여 `최소값과 위치를 교환`하며 정렬 <br>
ㅤ🔻**버블(Bobble) 정렬**: 정렬 대상 중 **기준값으로 선택된 데이터**와 **다음(오른쪽) 데이터를 비교**하여 정렬 <br>
ㅤ🔻**삽입(Insertion) 정렬**: 정렬 대상 중, **좌측에 이미 정렬된 요소**와 **비교**하여 **자신의 위치를 찾아 삽입**하는 정렬 <br>
ㅤ🔻쉘(Shell) 정렬: 많은 이동이 필요한 삽입 정렬의 단점 보완. `1.72 (N)^(1/3)`의 **간격별로 삽입정렬 진행** (간격이 1이 될 때까지) <br>
ㅤ🔻**힙(Heap) 정렬**: 정렬 대상을 **완전 이진 트리 형태로 만들어** 정렬. 루트 노드부터 차례로 추가(좌→우)하며 자식이 부모 보다 큰 경우 교환<br>
ㅤ🔻이진 병합(Merge) 정렬: **두 데이터를 한 쌍으로 병합하여 정렬**, 정렬된 두 그룹을 다시 한쌍으로 병합하여 정렬을 반복 <br>
ㅤ🔻버킷(Bucket) 정렬: 정렬 대상의 **데이터 범위를 균등하게 나눈 여러 버킷을 생성**하고, 각 버킷별 **스택을 이용하여 정렬** 후 하나의 리스트로 연결<br>
ㅤ🔻퀵(Quick) 정렬: 하나의 리스트를 **기준값을 기준으로 분할 및 정렬**, 분할된 범위에서 다시 반복하는 정렬 <br><br><br>

## 💠Chapter 02. 통합 구현
### 🔹Section 01. **연계 데이터 구성 ( ⭐ )**
> [!IMPORTANT]
> - [ ] **XML | JSON | AJAX**

✔  **연계 데이터 표준화** <br>
ㅤ**1️⃣** 연계 범위 및 항목 정의: 시스템 간 연계하려는 정보를 상세화하며 범위와 항목을 정의 <br>
ㅤ**2️⃣** 연계 코드 매핑 및 정의: 연계되는 정보 중 코드로 관리되어야 하는 항목을 변환 <br>
ㅤ**3️⃣** 변경된 데이터 구분 방식 정의: 연계 데이터 식별자와 변경 구분을 추가 <br>
ㅤ**4️⃣** 데이터 연계 방식 정의: 테이블은 컬럼을 통해 상세화 / 파일은 파일 형식에 따라 태그나 항목 분리자 사용 등으로 상세화 <br>
ㅤㅤㅤ🔻**XML[^25]**: **사용자가 임의로 생성한 태그**를 통해 상세화 <br>
ㅤㅤㅤ🔻**JSON[^26]**: XML을 대체하는 독립적인 **개방형 표준 형식**. **자바스크립트 기반**. **<속성,값>의 쌍으로 표현**. **AJAX[^27]** 기술에서 많이 사용 <br>
ㅤㅤㅤ🔻**Text 형식**: **항목 분리자(Delimiter: 콤마, 콜론, 세미콜론 등)** 를 통해 상세화  <br><br><br>

[^25]: **eXtensible Markup Language** (확장 가능한 마크업 언어)
[^26]: **JavaScript Object Notation** (자바스크립트 객체 표기법)
[^27]: **Asynchronous Javascript And XML** (비동기 자바스크립트와 XML)

### 🔹Section 02. **연계 메커니즘 구성 ( ⭐ )**
> [!IMPORTANT]
> - [ ] **오류 코드 | 채널 암호화 | 암호화 알고리즘**

✔  **연계 방식** <br>
ㅤ**1️⃣** **직접 연계**: **중간 매개체 없이 송/수신 시스템이 직접 연계되는 방식** <br>
ㅤㅤㅤ🔻**장점**: 연계 및 통합 구현 단순, 개발 비용 저렴, 연계 처리 성능 상승<br>
ㅤㅤㅤ🔻**단점**: 높은 결합도로 인터페이스 변경에 민감, 보안이나 로직 적용 불가<br>
ㅤ**2️⃣** **간접 연계**: **연계 솔루션과 같은 중간 매개체를 활용하여 연계되는 방식** <br>
ㅤㅤㅤ🔻**장점**: 다양한 환경 통합, 보안이나 로직 적용 반영 가능, 인터페이스 변경 가능<br>
ㅤㅤㅤ🔻**단점**: 연계 메커니즘 복잡, 성능 저하, 적용을 위한 테스트 기간 소요<br>

✔  **간접 연계 메커니즘 구성 요소** <br>
ㅤ**1️⃣** 연계 데이터 생성 및 추출 <br>
ㅤ**2️⃣** 코드 매핑 및 데이터 변환<br>
ㅤ**3️⃣** 인터페이스 테이블 or 파일 생성<br>
ㅤ**4️⃣** 로그 기록 (송수신 시스템에서의 모든 활동에 대한 결과 기록)<br>
ㅤ**5️⃣** 연계 서버: (인터페이스 송수신 관련 모든 처리를 전송 주기마다 수행)<br>
ㅤ**6️⃣** 연계 데이터 반영<br>

✔  **오류코드** <br>
ㅤ🔻**E**rror <br>
ㅤ🔻**오류 발생 위치**: **연계 서버(S), 연계 프로그램(A)** <br>
ㅤ🔻**오류 유형**: **형식(F), 길이(L), 코드(C), 데이터(D), 권한(S), 필수 입력(M)** <br>
ㅤ🔻**일련번호**: 오류 유형 및 분류별로 일련번호 부여 <br>
ㅤㅤㅤ✅ **E + 오류 발생 위치 + 오류 유형 + 일련번호** `ex. EAD002, ESS001` <br>

✔  **채널(Channel; 전송 구간) 암호화** <br>
ㅤ: **네트워크에서 데이터가 전송되는 형식**. **패킷의 암(복)호화**로 네트워크에서 전송 데이터 및 패킷을 가로채더라도 쉽게 내용 파악이 어려움 <br>
ㅤ🔻**전용선**: 송수신 시스템만을 위한 전용선 설치로 채널 암호화 솔루션 적용 <br>
ㅤ🔻**VPN**: Virtual Private Network. 공중망의 회선을 사설망처럼 활용하는 기술로 전용선 설치가 어려운 경우 VPN 활용 <br>

✔  **암호화 알고리즘** <br>
ㅤ**1️⃣** **암호화 방향**에 따른 구분 <br>
ㅤ🔻**단방향 알고리즘**: **암호화만 가능**한 알고리즘 `ex. HASH 기반 알고리즘`<br>
ㅤ🔻**양방향 알고리즘**: **암호화/복호화가 가능**한 알고리즘  `ex. 대칭키, 비대칭키`<br>
ㅤ**2️⃣** **송수신 시스템 간의 적용되는 암호화 키의 동일 여부**에 따른 구분<br>
ㅤ🔻**대칭키 알고리즘**: **동일한 암호화 키를 공유**하는 방식  `ex. AES, DES, WEP, TKIP` <br>
ㅤ🔻**비대칭키 알고리즘**: **서로 다른 암호화 키**를 사용하는 방식 `ex. RSA, DSA, DH, ElGamal` <br><br><br>

### 🔹Section 03. **연계 모듈 구현 ( ⭐⭐ )**
> [!IMPORTANT]
> - [ ] **EAI | ESB | 인터페이스 구현 검증 도구**

✔  **연계 기술 표준** <br>
ㅤ🔻 **Point-to-Point**: **미들웨어 없이 애플리케이션 간 직접 연결**하는 방식 <br>
ㅤ🔻 **Hub & Spoke(EAI)**: **단일 접점 시스템(허브)** 을 통해 데이터를 전송하는 **중앙 집중형 연계 방식** <br>
ㅤㅤ❗ **EAI[^28]**: 서로 다른 기종의 시스템 간의 연동을 가능하게 해주는 **전사적 애플리케이션 통합 환경** <br>
ㅤ🔻 **Message Bus(ESB[^29])**: **송수신 시스템 사이에 미들웨어(Bus)** 를 두어 확장성과 처리량이 향상되는 방식 <br>
ㅤ🔻 **EAI/ESB(Hybrid)**: **Hub&Spoke 방식을 사용하는 그룹들 사이를 ESB(허브)를 적용**한 표준 통합 기술<br>

[^28]: **Enterprise Application Intergration**
[^29]: **Enterprise Service Bus**

✔  **연계 테스트 및 검증** <br>
ㅤ**1️⃣** **연계 테스트** <br>
ㅤ**2️⃣** **연계 모듈 테스트 케이스 작성 및 명세화** <br>
ㅤ**3️⃣** **연계 시스템 검증** <br>
ㅤㅤㅤ🔻**xUnit**: java,c++ 등 다양한 언어를 지원하는 단위 테스트 프레임워크<br>
ㅤㅤㅤ🔻**STAF**: 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임 워크<br>
ㅤㅤㅤ🔻**FitNesse**: 웹 기반 테스트 케이스 설계/실행/결과 확인 등을 지원하는 테스트 프레임 워크<br>
ㅤㅤㅤ🔻**NTAF**: STAF와 FitNesse를 통합한 프레임 워크<br>
ㅤㅤㅤ🔻**Selenium**: 다양한 브라우저 지원 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크<br>
ㅤㅤㅤ🔻**watir**: Ruby 기반 웹 애플리케이션 테스트 프레임워크<br>
ㅤ**4️⃣** **인터페이스 예외 처리** <br>
ㅤㅤㅤ🔻**HTTP status code** <br>
ㅤㅤㅤㅤㅤㅤ**400: 잘못된 요청 / 401: 인증 실패 / 403: 접근 거부 문서 요청 / 404: 페이지 없음 / 408: 요청 시간 만료** <br>
ㅤㅤㅤㅤㅤㅤ**500: 내부 서버 오류 / 501: 구현되지 않음 / 502: 잘못된 게이트웨이 / 503: 서버 과부하**  <br>
ㅤ**5️⃣** **연계 시스템 구현 모니터링** <br>
ㅤㅤㅤ🔻**APM[^30]**: 사용자 환경에 설치하여 송수신 시스템의 기능 및 성능 운영 현황을 관리할 수 있는 모니터링 도구<br><br><br>

[^30]: **Application Performance Management**

## 💠Chapter 03. 제품 소프트웨어 패키징
### 🔹Section 01. **제품 소프트웨어 패키징 ( ⭐⭐ )**
> [!IMPORTANT]
> - [ ] **빌드 도구 | SW 패키징 | DRM**

✔  **소프트웨어 빌드 자동화 도구** <br>
ㅤ🔻 **Jenkins**: **Java언어 기반**, 웹 서버 기반, 형상 관리 도구 연동 가능 <br>
ㅤ🔻 **Gradle**: **groovyDSL 기반**, 오픈 소스, 태스크 단위 실행, 플러그인 활용 가능<br>

✔  **소프트웨어 패키징** <br>
ㅤ: 기능 식별 → 모듈화 → 빌드 진행 → 사용자 환경 분석 → 패키징 적용 시험 → 패키징 변경 개선<br>

✔  **DRM(Digital Rights Management; 디지털 저작권 관리 구성 요소)** <br>
ㅤ🔻 **콘텐츠 제공자**: 콘텐츠를 제공하는 저작권자<br>
ㅤ🔻 **콘텐츠 분배자**: 암호화된 콘텐츠 제공 `ex.쇼핑몰`<br>
ㅤ🔻 **패키저**: 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능<br>
ㅤ🔻 **보안 컨테이너**: 원본을 안전하게 유통하기 위한 전자적 보안 장치<br>
ㅤ🔻 **DRM 컨트롤러**: 배포된 콘텐츠의 이용 권한을 통제<br>
ㅤ🔻 **클리어링 하우스**: 키 관리 및 라이선스 발급 관리<br>

<div align="center">
  <img width="55%" src="https://blog.kakaocdn.net/dn/bLln6h/btq2x5elQrw/1ZUCkD4z7tf5ILhzBpF4Y0/img.png">
</div>
<br><br>

### 🔹Section 02. **제품 소프트웨어 메뉴얼 작성 ( ⭐ )**
> [!IMPORTANT]
> - [ ] **설치 매뉴얼 | 사용자 매뉴얼**

✔  **설치 매뉴얼** <br>
ㅤ: 기능 식별 → UI 분류 → 설치/백업 파일 확인 → Uninstall 절차 확인 → 이상 Case 확인<br>

✔  **사용자 매뉴얼** <br>
ㅤ: 컴포넌트 명세서/구현 설계서 → 사용자 매뉴얼 작성( 작성 지침 정의 → 구성 요소 정의 → 요소별 내용 작성 → 사용 매뉴얼 검토 ) → 사용 매뉴얼 작성 <br><br><br>

### 🔹Section 03. **제품 소프트웨어 버전 관리 ( ⭐ )**
> [!IMPORTANT]
> - [ ] **형상 관리 | 형상 관리 기능/역할 | 형상 관리 도구별 특징**

✔  **형상 관리 도구의 기능** <br>
ㅤ🔻 **check-out**: **저장소(repository)로부터 원하는 버전의 소프트웨어 형상의 사본을 컴퓨터로 가져오는 기능**<br>
ㅤ🔻 **check-in**: 개발자가 **수정한 소스 코드를 저장소에 업로드**하는 기능 <br>
ㅤ🔻 **commit**: 저장소 업로드가 성공적으로 완료되었을 때, **반영을 최종 승인**하는 기능 <br>
ㅤ🔻 **update**: **저장소와 컴퓨터의 형상을 동기화**하는 기능 (소스 코드 수정 전에 반드시 수행) <br>
ㅤ🔻 **import**: **비어 있는 저장소에 처음 소스를 업로드**하는 기능<br>
ㅤ🔻 **export**: **버전 관리 파일을 뺀 순수 코드 파일만 받아오는 기능** <br>

✔  **제품 소프트웨어 형상 관리 도구** <br>
ㅤ🔻 **ALM[^31]**: **전체 라이프 사이클을 관리**하는 발전된 형식의 형상 관리 <br>
ㅤ🔻 **ITIL[^32]**: **IT 서비스를 쉽게 제공하고 관리할 수 있는 가이드 또는 프레임워크** <br>
ㅤ🔻 **ITSM[^33]**: IT업무 및 관련 절차를 **기술 중심의 운영/관리에서 벗어나 서비스화 및 비즈니스 중심**으로 재설계. **SLA**[^34]에 맞는 IT 서비스 제공<br>
ㅤ🔻 IT Governance: 바람직한 IT 활용을 위한 의사결정 및 책임에 대한 프레임워크 <br>
ㅤ🔻 EAMS(EA Management System): EA[^35]의 관리 및 활용을 위한 구현 시스템<br>
ㅤ🔻 PPM(Project and Portfolio Management): 중앙 집중식 프로젝트 관리<br>


[^31]: **Application Lifecycle Management**
[^32]: **IT Infrastructure Library**
[^33]: **IT Service Management**
[^34]: **Service Level Agreement**: 협의된 서비스 수준
[^35]: **Enterprise Architecture**: 기업의 전략적인 목표에 도달하기 위한 IT 청사진


✔  **형상 관리 도구 유형별 특징** <br>
ㅤ**1️⃣** **방식에 따른 유형** <br>
<div align="center">
  
|**관리 방식**|**설명**|**예시**|
|:--:|:--:|:--:|
|공유 폴더|개발이 완료된 파일은 공유폴더에 복사하고 담당자는 자신의 PC로 다운로드하여 동작 여부 확인 후 각 개발자들이 동작 여부 확인|**RCS, SCCS**|
|클라이언트/서버|중앙 서버에서 형상 관리 시스템이 항시 동작되며, 개발자들의 작업내역을 축적할 수 있고 모니터링 가능|**CVS, SVN**|
|분산 저장소|중앙의 원격 저장소에서 개발자들의 개인 로컬 저장소에 복사하여 개발한 뒤, 다시 원격 저장소에 반영|**Git, Bitkeeper**|
</div>

ㅤ**2️⃣** **구분에 따른 유형** <br>
<div align="center">

|**구분**|**유형**|**예시**|
|:--:|:--:|:--:|
|저장소 구분|로컬 형상 관리 시스템|**RCS**|
| |중앙 집중형 형상 관리 시스템|**CVS, SVN, Clear Case**|
| |분산형 형상 관리 시스템|**Git, Mercurial**|
|소스 공개 유형|Open Source 관리 도구|**CVS, SVN**|
| |상용 형상 관리 도구|**PVCS, Clear Case**|

</div>

ㅤ🔻 **CVS[^36]**: **서버와 클라이언트로 구성**되어 **다수의 인원이 동시에 범용적인 운영체제로 접근 가능하여 형상 관리 가능하게 하는 도구**<br>
ㅤ🔻 **SVN(Subversion)**: CVS의 단점을 보완한 형상 관리 도구. **사실상 업계 표준으로 사용** <br>
ㅤ🔻 **RCS(Revision Control System)**: CVS와 달리 **소스파일의 수정을 한 사람으로 제한**하는 형상 관리 도구 <br>
ㅤ🔻 Bitkeeper: SVN과 비슷한 **중앙 통제 방식의 버전 컨트롤 툴**. 대규모 프로젝트에서 사용하는 형상 관리 도구 <br>
ㅤ🔻 **Git**: 리눅스 커널의 버전 컨트롤을 하는 Bitkeeper를 대체하기 위해 나온 형상 관리 도구. **속도에 중점을 둔 분산형 형상 관리 시스템** <br>
ㅤ🔻 Clear Case: IBM에서 제작된 **복수의 서버와 클라이언트가 연계**되는 구조, **서버의 추가가 가능한 형상 관리 도구** <br><br><br>

[^36]: Concurrent Version System

## 💠Chapter 04. 애플리케이션 테스트
### 🔹Section 01. **애플리케이션 테스트 케이스 설계 ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [ ] **테스트 원리 | 정적/동적 테스트 | 화이트박스/블랙박스 테스트 | 테스트 오라클**

✔  **테스트 원리** <br>
ㅤ🔻 **결함 집중(Defect Clustering)**: 결함의 대부분은 **특정 모듈에 집중되어 존재** <br>
ㅤㅤ**1️⃣** **낚시의 법칙**: 낚시 포인트처럼, **특정 위치에서 많은 결함 발생** <br>
ㅤㅤ**2️⃣** **파레토(Pareto)의 법칙**: **결함의 80%는 20%의 기능에서 발생** <br>
ㅤ🔻 **살충제 패러독스(Pesticide Paradox)**: **동일한 테스트 케이스로 반복 실행하면 결함 발견 불가능**(개선 필요) <br>
ㅤ🔻 **오류-부재의 궤변(Absence of Errors Fallacy)**: **결함이 없더라도 요구사항을 만족하지 못한다면 품질 보증 불가능** <br>

✔  **소프트웨어 테스트 절차** <br>
ㅤ: 테스트 계획 → 테스트 분석 및 디자인 → 테스트 케이스 및 시나리오 작성 → 테스트 수행 → 테스트 결과 평가 및 리포팅 <br>

✔  **소프트웨어 테스트 유형** <br>
ㅤ🔻 **정적 테스트**: **프로그램 실행 없이 소스 코드의 구조 분석 (인스펙션, 동료 검토, 워크스루 등)** <br>
ㅤ🔻 **동적 테스트**: **프로그램의 실행 화면을 보면서 테스트 수행 (화이트박스, 블랙박스)** <br>
ㅤㅤ**1️⃣** **화이트박스**: **프로그램의 내부 로직(경로 구조, 루프 등)** 을 중심으로 테스트를 진행 <br>
ㅤㅤㅤㅤ🔸**기초 경로(Basic Path) 테스트**: McCabe가 제안한 테스트 기법. 설계서나 **소스 코드를 기반으로 흐름도를 작성하여 논리적 순환 복잡도[^37]를 측정** <br>
ㅤㅤㅤㅤ🔸**제어구조 검사**: **소스 코드 내의 제어구조들에 대한 테스트 기법** ex. 조건 검사[^38], 루프 검사[^39], 데이터 흐름 검사[^40] <br>
ㅤㅤ**2️⃣** **블랙박스**: **프로그램의 기능(요구사항 만족 여부, 결과값)** 을 중심으로 테스트를 진행 <br>
ㅤㅤㅤㅤ🔸**오류 예측(Error Guessing)**: **과거의 경험이나 확인자의 감각에 의존**하여 테스트 케이스를 설계<br>
ㅤㅤㅤㅤ🔸**동등 분할(Equivalence Partitioning) 테스트**: **입력 조건에 유효한 값과 무효한 값을 균등**하게 하여 테스트 케이스를 설계<br>
ㅤㅤㅤㅤ🔸**경계값 분석(Boundary Value Analysis)**: **입력 조건의 경계에서 오류가 발생할 확률 높음**을 이용하여 입력 조건의 경계값을 테스트 케이스로 설계<br>
ㅤㅤㅤㅤ🔸**비교(Comparison) 테스트**: **여러 버번의 프로그램에 동일한 테스트 자료 제공**하여 테스트하는 기법<br>
ㅤㅤㅤㅤ🔸**원인-효과 그래프(Cause-Effect Graph) 테스트**: **입력 데이터 간의 관계와 출력에 미치는 영향을 분석**하여 효용성이 높은 테스트 케이스 설계<br>

[^37]: **복잡도 = 간선수 - 노드수 + 2**
[^38]: **Condition Testing; 논리식(조건)을 중심으로 테스트**
[^39]: **Loop Testing; 반복 구조를 중심으로 테스트**
[^40]: **Data Flow Testing; 변수의 정의와 사용을 중심으로 테스트**

✔  **테스트와 디버깅** <br>
ㅤ🔻 **검증(Verification)**: 제품의 개발(생산) **과정에 대한 테스트** (개발자 입장; 제대로 하고 있나?) <br>
ㅤ🔻 **확인(Validation)**: 제품의 개발(생산) **결과에 대한 테스트** (사용자 입장; 결과가 제대로인가?) <br>

✔  **테스트 오라클** <br>
ㅤ🔻 **참(True) 오라클**: **모든 입력값에 대하여 기대 결과 생성** (발생된 오류 모두 검출) <br>
ㅤ🔻 **샘플링(Sampling) 오라클**: **특정 몇 개의 입력값에 대해서만 기대 결과 제공**<br>
ㅤ🔻 **휴리스틱(Heuristic) 오라클**: 특정 입력값에 대해 기대 결과를 제공, **나머지 값들에 대해서는 추정(Heuristic)으로 처리** <br>
ㅤ🔻 **일관성 검사(Consistent) 오라클**: 애플리케이션 변경이 있을 때, **수행 전과 후의 결과값이 동일한지 확인** <br><br><br>

### 🔹Section 02. **애플리케이션 통합 테스트 ( ⭐⭐ )**
> [!IMPORTANT]
> - [ ] **상향식/하향식 통합 | 스텁(stub) | 드라이버(driver) | 결함 | 커버리지(Coverage)**

✔  **V-모델 (통합 테스트)** <br>
<div align="center">
  <img width="60%" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdR8j8F%2Fbtq3bGLQFyW%2FviGBQi3klMwdwzURj2AW01%2Fimg.png">
</div>

ㅤ🔻 **단위 테스트**: **모듈(컴포넌트)**의 기능을 중심으로 테스트. 일반적으로 화이트박스 테스트 진행<br>
ㅤ🔻 **통합 테스트**: **각 모듈 간의 인터페이스** 관련 오류 및 결함을 찾아내기 위한 테스트 기법들의 총칭<br>
ㅤㅤ**1️⃣** **비점증적 방식**: **모든 모듈을 통합한 전체 프로그램**을 한 번에 테스트 <br>
ㅤㅤㅤ🔸**빅뱅**: 모든 모듈을 동시에 통합 후 테스트. 작은 시스템, 단기간 프로젝트에 사용. <br>
ㅤㅤ**2️⃣** **점증적 방식**: **통합 단계별로 테스트를 수행**하는 방식 <br>
ㅤㅤㅤ🔸**하향식 통합**: **최하위 모듈부터 상위 모듈로 단계별로 통합**하며 테스트 `ex. 깊이 우선, 너비 우선` <br>
ㅤㅤㅤㅤ❗ **stub**: **상위 모듈의 테스트를 위한 최소한의 기능만 가지는 더미 모듈** <br>
ㅤㅤㅤ🔸**상향식 통합**: **최상위 모듈로부터 하위 모듈로 단계별로 통합(클러스터화)** 하며 테스트 <br>
ㅤㅤㅤㅤ❗ **driver**: **테스트 단계에 존재하지 않는 상위 모듈의 역할을 하는 더미 모듈** <br>
ㅤㅤ**️➕** **회귀 테스트**: 통합 테스트가 완료된 후에 **변경된 모듈이나 컴포넌트**가 있다면 **새로운 오류 여부를 확인**하기 위해 수행 <br>
ㅤ🔻 **시스템 테스트**: **개발된 소프트웨어가 목표 컴퓨터 시스템**에서 완벽하게 수행되는 지 확인하는 테스트<br>
ㅤ🔻 **인수 테스트**: 개발이 완료된 소프트웨어에 대해 **사용자 요구사항 충족 여부를 사용자가 직접 테스트**하는 것 <br>
ㅤㅤ**1️⃣** **알파 테스트**: **개발자의 장소에서 사용자와 진행되는 테스트** <br>
ㅤㅤ**2️⃣** **베타 테스트**: **제한되지 않은 환경에서 개발자 없이 테스트** <br>

✔  **테스트 하네스(Test Harness)** <br>
ㅤ: 테스트를 지원하기 위한 코드와 데이터들의 총칭<br>
ㅤ🔻 **테스트 스위트(Test Suites)**: 테스트 대상 컴포넌트나 모듈, 시스템에서 **사용되는 테스트 케이스의 집합**<br>
ㅤ🔻 **테스트 케이스(Test Case)**: **입력값, 실행 조건, 기대 결과 등의 집합**<br>
ㅤ🔻 **테스트 스크립트(Test Script)**: **자동화된 테스트 실행 절차에 대한 명세**<br>
ㅤ🔻 **목 오브젝트(Mock Object)**: **사용자의 행위를 조건부로 사전에 입력**해 두면, 그 **상황에 예정된 행위를 수행하는 객체**<br>

✔  **소프트웨어 결함** <br>
ㅤ🔻 **오류(Error)**: **결함의 원인. 일반적으로 휴먼 에러에 의해 생성**<br>
ㅤ🔻 **결함(Defect) / 결점(Fault) / 버그(Bug)**: **제품에 포함된 완전하지 못한 부분**<br>
ㅤ🔻 **실패(Failure) / 문제(Problem)**: **결함에 의해 의도하지 않은 결과가 발생하는 것**<br>

✔  **테스트 커버리지(Coverage)** <br>
ㅤ: 주어진 테스트 케이스에 의해 수행되는 **SW의 테스트 범위를 측정하는 테스트 품질 측정 기준** <br>
ㅤ🔻 기능 기반 커버리지: 대상 애플리케이션의 **전체 기능을 모수로 설정**하고, 실제 테스트가 수행된 **기능의 수를 측정** <br>
ㅤ🔻 라인 커버리지: 대상 애플리케이션의 **전체 소스 코드 라인수를 모수로 설정**하고, 테스트가 수행한 **라인 수를 측정**<br>
ㅤ🔻 코드 커버리지: 소프트웨어 테스트를 충분히 진행했는지를 나타내는 지표. **소스 코드의 구조 코드 자체가 얼마나 테스트 됐는지 측정**<br>
ㅤㅤㅤㅤ`ex. 구문(Statement)  /  결정(Decision)  /  조건(Condition)  /  조건/결정  /  변형 조건/결정  /  다중 조건` 커버리지 <br><br><br>

### 🔹Section 03. **애플리케이션 성능 개선 ( ⭐⭐⭐ )**
> [!IMPORTANT]
> - [x] **클린 코드 | 코드 분석 도구 | 소프트웨어 품질 평가 항목 | 정형 기술 검토**

✔  **애플리케이션 성능 측정** <br>
ㅤ🔻 **처리량(Throughput)**: 주어진 시간에 처리할 수 있는 **단위 작업(트랙잭션)의 수**<br>
ㅤ🔻 **응답 시간(Response Time)**: 사용자 입력에 대한 **응답이 나타날 때까지의 시간**<br>
ㅤ🔻 **경과 시간(Turn-around Time)**: 사용자 입력에 대한 **결과 출력이 완료될 때까지의 시간**<br>
ㅤ🔻 **자원 사용률(Resource Usage)**: 단위 작업 처리를 위한 CPU, 메모리, 네트워크 등의  **자원 사용량**<br>

✔  **애플리케이션 성능 저하 원인 - DB** <br>
ㅤ🔻 **DB Lock**: 대량의 데이터 조회, 과도한 업데이트 및 인덱스 생성 시 **DB가 잠기는 현상**<br>
ㅤ🔻 **DB Fetch**: 필요한 데이터보다 많은 양의 데이터 요청이 들어올 경우 **응답 시간 저하** 발생<br>

✔  **소스 코드 품질 분석** <br>
ㅤ🔻 **코드 인스펙션(Code Inspection)**: **코드에 존재하는 결함을 확인하는 검사**<br>
ㅤ🔻 **증명(Proof)**: 소프트웨어 품질이 매우 중요한 경우 활용 (**모든 기대 결과와 실제 결과 비교**) <br>
ㅤ🔻 **리팩토링(Refactoring)**: `코드의 기능 변경 없이` **구조를 개선**하여 안정성과 가독성 확보<br>

✔  **소스 코드 품질 분석 도구** <br>
ㅤ**1️⃣** **소스 코드 정적 분석 도구**: **작성된 코드를 실행시키지 않고**, 코드 자체만으로 품질 분석을 진행하는 도구<br>
ㅤㅤ🔻 **pmd**: **자바 및 다른 언어의 소스 코드**에 대한 버그 및 데드 코드 분석<br>
ㅤㅤ🔻 **cppcheck**: **C/C++ 코드**에 대한 메모리 누수, 오버플로우 등 분석<br>
ㅤㅤ🔻 SonarQube: **소스 코드 통합 플랫폼**, 플러그인 확장 가능<br>
ㅤㅤ🔻 checkstyle: **자바 코드**에 대한 코딩 표준 준수 검사 도구<br>
ㅤ**2️⃣** **소스 코드 동적 분석 도구**: 애플리케이션을 실행하여 코드의 품질을 분석하는 도구<br>
ㅤㅤ🔻 Avalanche: Valgrind[^41] 프레임워크 및 STP 기반 소프트웨어 에러 및 취약점 분석<br>

[^41]: **자동화된 메모리 및 스레드 결함 발견 및 분석** 

✔  **소프트웨어 품질 평가** <br>
ㅤ❗ **소프트웨어 품질 보증(SQA[^42])**: `제품 소프트웨어의 기능`과 `사용자의 요구사항`이 **일치하는지를 확인**하는 시스템과 활동의 총칭<br>
ㅤ🔻 **정형 기술 검토(FTR[^43])**: 가장 일반적으로 `정형화된 기술 검토 방법`. (정적 분석 기법) <br>
ㅤ🔻 **시스템 신뢰도 측정** <br>
ㅤㅤ❗ 평균 무장애 시간(MTBF[^44]): (수리 가능 제품)`평균 장애 발생 간격 평균`. MTBF = MTTF + MTTR<br>
ㅤㅤ❗ 평균 장애 시간(MTTF[^45]): (수리 불가능 제품)`고장이 발생할 때까지의 동작시간 평균`. MTTF = 총 동작시간 / 사용횟수<br>
ㅤㅤ❗ 평균 복구 시간(MTTR[^46]): `고장이 발생한 시점부터 수리가 완료될 때까지의 수리시간 평균`. MTTR = 총 고장시간 / 사용횟수<br><br><br> 

[^42]: **Software Quality Assurance**
[^43]: **Formal Technical Review**
[^44]: **Mean Time Between Failure**
[^45]: **Mean Time To Failure**
[^46]: **Mean Time To Repair**

----------------------------------------------------------------------------------------------------------------------------

# ✳️ 과목 3. 데이터베이스 구축
## 💠Chapter 01. 논리 데이터베이스 설계
### 🔹Section 01. **데이터베이스 기본 ( ⭐ )**
> [!IMPORTANT]  
> - [ ] **DB 시스템 | 스키마 | RDBMS | 개체타입 | 키**

✔  **DB 시스템** <br>
ㅤ: 업무 수행에 필요하고 관련 있는 데이터의 체계적인 집합<br>
ㅤㅤ🔻 실시간 접근성: 사용자 요청에 실시간으로 응답하여 처리<br>
ㅤㅤ🔻 계속적인 진화: 데이터의 생성이나 변경, 삭제 등을 통해 항상 최신 상태 유지<br>
ㅤㅤ🔻 동시 공유: 여러 사용자가 동시에 원하는 데이터 이용 가능<br>
ㅤㅤ🔻 내용에 의한 참조: 데이터 위치가 아닌 사용자가 요구하는 데이터 내용에 따라 데이터를 참조<br>
ㅤㅤ🔻 데이터의 논리적 독립성: 응용 프로그램과 DB를 분리하여 데이터의 논리적 구조 변경에도 응용 프로그램을 변경할 필요 없음<br>

✔  **스키마(Schema)** <br>
ㅤ🔻 **외부 스키마**: **특정 사용자**의 입장에서 필요한 DB의 구조를 정의한 스키마 <br>
ㅤ🔻 **개념 스키마**: **모든 사용자(조직)** 의 입장에서 필요한 DB의 구조를 정의한 스키마. DB당 하나 존재 <br>
ㅤ🔻 **내부 스키마**: **물리적인 저장장치**의 입장에서 필요한 DB의 구조를 정의한 스키마 <br>

✔  **DBMS** <br>
ㅤ: **사용자와 DB 사이에서 데이터를 저장하고 분석하기 위해 상호작용하는 시스템** <br>
ㅤ**1️⃣** **DBMS의 구성**<br>
ㅤㅤ🔻 질의어 처리기: 사용자가 입력한 **질의어를 분석하여 데이터베이스 처리기로 전송**<br>
ㅤㅤ🔻 DML 컴파일러: 응용 프로그램에서 작성된 **DML 명령어를 분석하여 데이터베이스 처리기로 전송**<br>
ㅤㅤ🔻 데이터베이스 처리기: DB가 실행되는 동안 **DB 연산을 저장 데이터 관리자에 전송**<br>
ㅤㅤ🔻 DDL 컴파일러: DBA가 작성한 **DDL이나 스키마를 분석하여 저장 데이터 관리자에 전송**<br>
ㅤㅤ🔻 저장 데이터 관리자: **DB와 데이터 사전의 접근 관리, 운영체제에 파일 접근 요청**<br>
ㅤ**2️⃣** **DBMS의 필수 기능**<br>
ㅤㅤ🔻 **정의 기능**: **데이터의 논리적, 물리적 구조 정의**<br>
ㅤㅤ🔻 **조작 기능**: **데이터 조회, 생성, 삭제, 변경 조작**<br>
ㅤㅤ🔻 **제어 기능**: **동시성 제어(데이터 동시 사용 관리), 보안과 권한 기능**<br>

✔  **관계형 데이터베이스** <br>
ㅤ**1️⃣** **DB 시스템 유형**<br>
ㅤㅤ🔻 **HDBMS(Hierarchical)**: **데이터를 계층화하여 관리**. 상하 종속적이라 구조 변화에 어려움. 1:N 관계<br>
ㅤㅤ🔻 **NDBMS(Network)**: **데이터를 네트워크 형태로 관리**. 상하 종속관계 해결(데이터 종속성은 해결 불가). N:M까지 표현 가능<br>
ㅤㅤ🔻 **RDBMS(Relational)**: **데이터를 테이블 구조로 모델링하여 관리**. 레코드가 아닌 테이블(릴레이션)을 기준으로 관계 설정<br>
ㅤ**2️⃣** **관계형 데이터베이스 용어**<br>
ㅤㅤ🔻 **개체 타입(Entity Type)**: 현실 세계의 개념이나 대상을 DB로 표현하고자 하는 **논리적인 표현 단위**. 다수의 속성으로 표현<br>
ㅤㅤ🔻 **속성(Attribute)**: **개체를 구성하는 고유의 특성**. 의미 있는 데이터의 가장 작은 논리적 단위<br>
ㅤㅤ🔻 **도메인(Domain)**: `하나의 속성값`이 가질 수 있는 **모든 원자값의 집합**<br>
ㅤㅤ🔻 **튜플(Tuple)**: `하나의 개체(레코드)`를 표현하는 **완전하고 고유한 정보 단위**<br>
ㅤㅤ🔻 **릴레이션(Relation)**: `개체의 관한 데이터`를 **속성과 튜플로 구성**된 2차원 테이블의 구조로 표현<br>
ㅤㅤㅤ❗ **릴레이션 스키마**: 릴레이션에 포함된 **속성명 집합(논리적 구조)** <br>
ㅤㅤㅤ❗ **릴레이션 어커런스(Occurrence)**: **릴레이션 인스턴스**와 같은 의미<br>
ㅤㅤㅤ❗ **기수(Cardinality)**: **전체 튜플의 개수(행 개수)** <br>
ㅤㅤㅤ❗ **차수(Degree)**: **전체 속성의 개수(열 개수)** <br>

<div align="center">
  <img width="55%" src="https://postfiles.pstatic.net/MjAyMTAzMTRfMjQ4/MDAxNjE1NjU0MTgwMDIy.wdIpiklKXrEZfrInoudziJoVHM93PO5I9n7z1OQ6ThMg.bf0Rb4QB6R8mZqRAG1NWa1FJN2b9OwOxWmIdrj2SYIsg.PNG.taeheon714/image.png?type=w966">
</div><br>

✔  **키(Key)** <br>
ㅤ🔻 **후보키(Candidate)**: **릴레이션에 존재하는 모든 튜퓰에 대해 유일성과 최소성을 모두 만족시키는 속성**<br>
ㅤㅤ❗ **유일성**: **튜플을 유일하게 구분할 수 있는 성질**<br>
ㅤㅤ❗ **최소성**: **가장 적은 수의 속성(하나의 속성)으로 구성되는 성질**<br>
ㅤ🔻 **기본키(Primary)**: **후보키의 특징(유일성, 최소성)을 만족하면서 중복과 Null을 갖지 않는 식별을 위한 키**<br>
ㅤ🔻 **대체키(Alternate)**: **기본키로 지정된 속성을 제외한 후보키들**<br>
ㅤ🔻 **슈퍼키(Super)**: **유일성을 만족하는 속성. 둘 이상의 속성을 합칠 수 있다.**<br>
ㅤ🔻 **외래키(Foreign)**: **다른 릴레이셔의 기본키를 참조하는 속성**<br><br><br>

### 🔹Section 02. **논리 개체 상세화 ( ⭐ )**
> [!IMPORTANT] 
> - [ ] **식별자**
> - [ ] **데이터 모델**
> - [ ] **관계** 

✔  **논리 개체** <br>
ㅤ🔻 **개체**: 현실 세계의 식별 가능한 대상을 디지털화하기 위해 **추상화(개체 타입)하여 표현(개체)한 단위** <br>
ㅤ🔻 **속성**: **개체의 정보를 나타내는 고유의 특성**<br>
ㅤ🔻 **식별자**: 하나의 개체 타입에서 각각의 개체를 **유일하게 구분할 수 있는 결정자. 키와 같은 의미**<br>
ㅤㅤㅤ❗ 식별자는 **대표성 여부[^47], 자체 생성 여부[^48], 단일 속성 여부[^49], 대체 여부**[^50]에 따라 다양한 형태로 나뉜다.

[^47]: 주 식별자 - 보조 식별자
[^48]: 내부 식별자 - 외부 식별자
[^49]: 단일 식별자 - 복합 식별자
[^50]: 원조 식별자 - 대리 식별자

✔  **데이터 모델링** <br>
ㅤ: 현실 세계의 개념적인 기업의 정보 구조를 디지털 세계의 논리적인 데이터 모델로 명확하고 체계적으로 변환하여 **문서화**하는 기법<br>
ㅤ🔻 개념 데이터 모델링: 비즈니스 요구사항을 표현한 상위 수준의 모델. **데이터 모델의 골격을 설계**. 주로 엔티티타입 간의 관계 파악<br>
ㅤ🔻 논리 데이터 모델링: 개념 데이터 모델을 기초로 하여 **업무 데이터 및 규칙을 구체적으로 표현**<br>

✔  **관계(Relationship)** <br>
ㅤ: 둘 이상의 개체 간에 존재나 행위에 있어 의미 있는 연결 상태<br>
ㅤ🔻 **속성 관계(개체 내)**: 개체를 기술하기 위해 해당 **개체가 가지는 속성들 사이의 관계**를 나타낸 것<br>
ㅤ🔻 **개체 관계(개체 간)**: **개체와 개체 사이의 관계**를 나타낸 것<br>
ㅤ🔻 **종속(Dependent) 관계**: 개체와 개체 사이의 **주종 관계**를 나타낸 것 <br>
ㅤㅤㅤ`ex. 식별 관계(개체의 외래키가 기본키에 포함) / 비식별 관계(개체의 외래키가 기본키에 포함 X)`<br>
ㅤ🔻 **중복(Redundant) 관계**: 특정 두 개체들 사이에 **두 번 이상의 종속 관계가 발생**하는 관계<br>
ㅤ🔻 **재귀(Recursive) 관계**: 특정 개체가 **자기 자신을 다시 참조하는 관계**<br>
ㅤ🔻 **상호 배타적 관계**: `특정 속성의 조건이나 구분자`를 통해 **개체 특성을 분할하는 일반화 관계**를 나타낸 것. **배타적 OR 관계**<br><br><br>

### 🔹Section 03. **논리 E-R 다이어그램 ( ⭐ )**
> [!IMPORTANT]  
> - [ ] **ERD**
> - [ ] **표기법**
> - [ ] **확장 ERD**

✔  **E-R 다이어그램(ERD; Entity-Relationship Diagram)** <br>
ㅤ: 데이터의 개념을 일관되게 인식할 수 있도록 **개체와 개체 간 관계를 미리 약속된 도형을 사용하여 알기 쉽게 표현한 도표**<br>
ㅤㅤ❗ ERD의 기본 구성 요소는 **개체, 관계, 속성**<br>
ㅤ🔻 **E-R 다이어그램 표기법**<br>
ㅤㅤ**1️⃣** **Peter-Chen 표기법** <br>
<div align="center">
  <img width="40%" src="https://blog.kakaocdn.net/dn/bjH4Pt/btqIlu0gD4f/p7Oztg8o4B5k8UHKKFLyi1/img.png">
</div>

ㅤㅤ**2️⃣** **IE(Information Engineering) / Crow's Foot 표기법** <br>
<div align="center">
  <img width="55%" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FBtnbi%2FbtreMCqOwt8%2FgTUP9EvmTxkWx9D5OmVob0%2Fimg.png">
</div>

✔  **확장 E-R 다이어그램** <br>
ㅤ❗ **슈퍼/서브 타입**: **하나의 상위 개체 타입이 다수의 하위 개체 타입과 관계될 때**, 각각 **슈퍼/서브 타입**이라 함 <br>
ㅤㅤㅤ🔸 `배타적(Exclusive) 서브타입`: 서브 타입 중 하나와 통합(**중복 선택 불가**; 배타적 OR 관계) <br>
ㅤㅤㅤ🔸 `포괄적(Inclusive) 서브 타입`: 서브 타입 중 하나 또는 다수와 통합(**중복 선택 가능**)`<br>

ㅤ**1️⃣** **일반화(Generalization) / 구체화(Specialization)** <br>
ㅤㅤㅤ🔻 **일반화**: **다수의 하위 개체 타입을 상위 개체의 유형 간 부분 집합으로 표현하는 상행식 설계 방식** <br>
ㅤㅤㅤ🔻 **구체화**: **개체 타입을 다수의 하위 개체 타입으로 분리하는 하행식 설계 방식**<br>
ㅤㅤㅤㅤ✅ **하위 개체 is a 상위 개체.** `ex. 컴퓨터 - (데스크탑, 노트북, 모바일)`<br>
ㅤ**2️⃣** **집단화(Aggregation) / 분해화(Decomposition)** <br>
ㅤㅤㅤ🔻 **집단화**: **특정 유형과 관련 있는 개체 타입들을 통해 새로운 개체 타입을 생성하는 방식**<br>
ㅤㅤㅤ🔻 **분해화**: **개체의 결합으로 이루어진 개체를 다시 하나하나 나누는 방식**<br>
ㅤㅤㅤㅤ✅ **부품 개체 is part of 결합 개체.** `ex. 컴퓨터 - (CPU, Memory, Graphics)`<br>
ㅤ**3️⃣** **분류화(Classification) / 인스턴스화(Instantiation)** <br>
ㅤㅤㅤ🔻 **분류화**: **특정 유형을 공통적으로 가지는 하위 개체들을 묶어 하나의 상위 개체로 정의하는 방식**<br>
ㅤㅤㅤ🔻 **인스턴스화**: **한 개체의 특성을 기본으로 하는 여러 형태의 개체를 생성하는 방식**<br>
ㅤㅤㅤㅤ✅ **하위 개체 is member of 상위 개체.** `ex. 컴퓨터 - (삼성 컴퓨터, 애플 컴퓨터, LG 컴퓨터)`<br><br><br>

### 🔹Section 04. **데이터베이스 정규화 ( ⭐⭐⭐ )**
> [!IMPORTANT]  
> - [ ] **데이터 종속성 | 정규화 단계 | 이상 현상**

✔  **데이터 종속성(Data Dependency)** <br>
ㅤ❗ **A → B일 때, A 속성을 결정자(Determinant), B 속성을 종속자(Dependent)** <br>
ㅤ🔻 **함수(Functional) 종속**: **한 속성이 다른 속성을 유일하게 식별할 수 있는 상태의 종속성**<br>
ㅤㅤ`ex. A→B 또는 B=F(A)  /  A→C, A→D 또는 A→{C,D}` <br>
ㅤ🔻 **다치(MultiValued) 종속**: **하나의 결정자가 다른 여러 관련 없는 속성의 값을 결정하는 종속성**<br>
ㅤㅤ`ex. G→H|J   : G 속성이 H와 J속성을 식별하지만 H와 J는 서로 관련이 없는 경우` <br>
ㅤ🔻 **조인(Join) 종속**: **릴레이션을 셋 이상의 릴레이션으로 분해한 뒤 다시 조인하여 복원될 수 있는 종속성**<br>

✔  **정규화(Normalization)** <br>
ㅤ: **데이터 무결성을 유지하기 위해 중복성을 최소화하고 정보의 일관성을 보장하기 위한 개념**<br>
ㅤ🔻 **비정규형**: 정규화가 전혀 진행되지 않은 상태<br>
ㅤ🔻 **1NF(제1정규형)**: `도`**메인이 원자값만 가지도록 분해** <br>
ㅤ🔻 **2NF(제2정규형)**: `부`**분 함수 종속 제거** <br>
ㅤ🔻 **3NF(제3정규형)**: `이`**행적 함수 종속 제거** <br>
ㅤ🔻 **BCNF(Boyce-Codd정규형)**: `결`**정자가 후보키가 아닌 종속 제거** <br>
ㅤ🔻 **4NF(제4정규형)**: `다`**치 종속 제거** <br>
ㅤ🔻 **5NF(제5정규형)**: 후보키를 통하지 않는 `조`**인 종속 제거** <br>

✔  **이상현상(Anomaly)** <br>
ㅤ🔻 **삽입 이상**: 튜플 삽입 시, **관련 없는 정보도 함께 삽입**해야 하는 현상<br>
ㅤ🔻 **갱신 이상**: 튜플 갱신 시, **데이터의 불일치**가 발생하는 현상<br>
ㅤ🔻 **삭제 이상**: 튜플 삭제 시, **관련된 정보도 함께 삭제**해야 하는 현상<br><br><br>

## 💠Chapter 02. SQL 활용
### 🔹Section 01. **구조적 질의어 ( ⭐⭐⭐ )**
> [!IMPORTANT]  
> - [x] **DDL | DML | DCL | 관계 대수 | 관계 해석**

✔  **SQL(Structured Query Language)** <br>
ㅤ: **관계형 데이터베이스를 제어하는 DBMS의 표준 언어**로 관계 대수를 기초로 만들어졌다.<br>
ㅤ🔻 **데이터 정의어(DDL; Definition)**: **CREATE, DROP, ALTER, TRUNCATE** <br>
ㅤ🔻 **데이터 조작어(DML; Markup)**: **SELECT, DELETE, INSERT, UPDATE** <br>
ㅤ🔻 **데이터 제어어(DCL; Control)**: **GRANT, REVOKE, COMMIT(트랜잭션 결과반영), ROLLBACK(TS 작업취소), CHECKPOINT(TS 복귀지점설정)** <br>
ㅤㅤ❗ **트랜잭션 제어어(TCL;Transaction Control)**: 트랜잭션 관련 명령어는 작업 대상이 서로 다르기 때문에 TCL이라는 별도의 분류 사용 <br>

✔  **관계 해석 논리 기호** <br>
ㅤ🔻 **관계 해석 연산자**: **AND(∧), OR(∨), NOT(¬)** <br>
ㅤ🔻 **관계 해석 정량자**: **전칭 정량자(Universal Quantifier, ∀ (all))  /  존재 정량자(Existential Quantifier, ∃ (any))** <br>

✔  **관계 대수(Relational Algebra)** <br>
ㅤ🔻 **일반 집합 연산자**: **합집합(Union, ⋃), 교집합(Intersection, ⋂), 차집합(Difference, -), 교차곱(Cartesian Product, ⨉)** <br>
ㅤ🔻 **순수 관계 연산자**: **SELECT(σ), PROJECT(=조건 만족, π), JOIN(⋈), DIVISION(=조건 만족x, ÷)** <br><br><br>


### 🔹Section 02. **SQL 활용 ( ⭐⭐⭐ )**
> [!IMPORTANT]  
> - [ ] **CASCADE | RESTRICT | 삭제/조회/권한 부여 문법**

✔  **데이터 생성 옵션** <br>
ㅤ🔻 대표적인 **제약 조건**<br>
ㅤㅤ🔸 **UNIQUE**: **유일키(식별자) 정의** <br>
ㅤㅤ🔸 **NOT NULL**: **공백값을 허용하지 않음** <br>
ㅤㅤ🔸 **CHECK** **컬럼에 허용되는 값을 제한** <br>

```MySQL
# 자주 사용하는 제약조건 예시
## 기본키 정의
PRIMARY KEY ( <컬럼명>[, ...] )

## 외래키 정의
FOREIGN KEY ( <컬럼명>[, ...] ) REFERENCES ( <컬럼명>[, ...] )

## 데이터 갱신 시 처리옵션에 따라 작업 수행
ON UPDATE <처리옵션>

## 데이터 삭제 시 처리옵션에 따라 작업 수행
ON DELETE <처리옵션>
```
ㅤ🔻 **데이터 갱신 및 삭제의 처리옵션**<br>
ㅤㅤ🔸 **CASCADE**: **관련된 튜플 모두 함께 처리** <br>
ㅤㅤ🔸 **RESTRICT**: **관련된 튜플이 없는 경우에만 처리** <br>
ㅤㅤ🔸 **NULLIFY**: **관련 튜플을 (삭제하는 대신) NULL 값으로 수정** <br>
ㅤㅤ🔸 **NO ACTION**: **무시** <br>
ㅤㅤ🔸 **SET DEFAULT**: **관련 튜플 모두 기본값 지정** <br>
ㅤㅤ🔸 **SET NULL**: **공백** <br>

✔  **데이터 정의어(DDL)** <br>
ㅤ🔻 **CREATE**<br>
```MySQL
# DB 객체 생성
CREATE <객체 유형> <객체명>(<옵션>);

# 테이블 생성
CREATE TABLE <테이블명>(
  <컬럼명> <데이터 유형> [<제약조건>] [, ...],
  [테이블 제약조건]
);
```
ㅤ🔻 **ALTER**<br>
```MySQL
# 컬럼 추가
ALTER TABLE <테이블명> ADD <필드명> <데이터타입> [<위치옵션>]   -- 위치 옵션: FIRST / AFTER <컬럼명>

# 컬럼 변경
ALTER TABLE <테이블명> MODIFY <컬럼명> <데이터유형>;
ALTER TABLE <테이블명> RENAME COLUMN <원본컬럼명> TO <변경컬럼명>;

# 컬럼 삭제
ALTER TABLE <테이블명> DROP <컬럼명>;


# 제약조건 추가
ALTER TABLE <테이블명> ADD CONSTRAINT <제약조건명> <제약조건>;

# 제약조건 변경
ALTER TABLE <테이블명> 옵션 <제약조건명>;   -- 활성화 옵션: ENABLE / DISABLE / DROP CONSTRAINT
```
ㅤ🔻 **DROP**<br>
```MySQL
# DB 객체 삭제
DROP <객체 유형> <객체명> [<삭제옵션>]

# 레코드 삭제
TRUNCATE TABLE <테이블명>;
```

✔  **데이터 조작어(DML)** <br>
ㅤ🔻 **INSERT**<br>
```MySQL
INSERT INTO <테이블명> VALUES (<값>[, ...]);
INSERT INTO <테이블명> (<컬럼명>[, ...]) VALUES (<값>[, ...]);
INSERT INTO <테이블명> (<필드>[, ...]) <SELECT문>;  -- 다른 테이블 레코드 복사하여 삽입
```
ㅤ🔻 **UPDATE**<br>
```MySQL
UPDATE <테이블명> SET <컬럼명>=<값>[, ...] WHERE <조건식>;
```
ㅤ🔻 **DELETE**<br>
```MySQL
DELETE FROM <테이블명> WHERE <조건식>;
```
ㅤ🔻 **SELECT**<br>
```MySQL
SELECT [ALL | DISTINCT] <컬럼명>[, ...]
FROM <테이블명>
[[WHERE <조건식>]
[GROUP BY <컬럼명> [HAVING] <조건식>]
[ORDER BY <컬럼명> [ASC | DESC]]];
```

✔  **SELECT 활용** <br>
ㅤ**1️⃣** **AS** <br>
ㅤㅤ🔻 **집계함수**: **COUNT(), SUM(), AVG(), MAX(), MIN(), STDDEV(), VARIAN()** <br>
ㅤㅤ🔻 AS <br>
ㅤㅤ🔻 **윈도우 함수**: **OLAP함수라고도 함. RANK, DENSE_RANK, ROW_NUMBER / FIRST_VALUE, LAST_VALUE, LAG, LEAD** <br>
ㅤ**2️⃣** **조건식**: **AND, OR, IS NULL, LIKE**<br>
ㅤ**3️⃣** **서브 쿼리(Sub Query)** <br>
ㅤㅤ🔻 단일 행 서브 쿼리: **=, <>, >, >=, <, <=** <br>
ㅤㅤ🔻 다중 행 서브 쿼리: **IN, ANY, SOME, ALL, EXISTS** <br>
ㅤ**4️⃣** **정렬과 그룹** <br>
ㅤㅤ🔻 정렬: **ASC, DESC** <br>
ㅤㅤ🔻 그룹: **ROLLUP(), CUBE(), GROUPING SET(), GROUPING()** <br>
ㅤ**5️⃣** **JOIN** <br>

<div align="center">
  <img width="45%" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F26242F48569460C734">
</div>

✔  **데이터 제어어(DCL)** <br>
ㅤ🔻 **GRANT**<br>
```MySQL
GRANT <권한 유형> TO <대상> [WITH GRANT OPTION | WITH ADMIN OPTION];
  -- WITH GRANT OPTION: 부여받은 권한을 다른 사용자에게 부여, 회수 가능
  -- WITH ADMIN OPTION: 부여받은 권한을 다른 사용자에게 부여만 가능
```
ㅤ🔻 **REVOKE**<br>
```MySQL
REVOKE <권한 유형> FROM <대상>;
```
ㅤ🔻 **ROLE**<br>
```MySQL
CREATE ROLE <역할명>;
GRANT <권한>[, ...] TO <역할명>;
GRANT <역할명> TO <사용자>[, ...];
```

✔  **트랜잭션** <br>
ㅤ: **DB를 조작하는 논리적 연산**들이 하나 이상 모인 단위 작업(**분해할 수 없는 최소 단위**) <br>
ㅤ🔻 **특징** <br>
ㅤㅤ🔸 **원자성(Atomicity)**: **모든 연산이 수행되거나 하나도 수행되지 말아야 함** <br>
ㅤㅤ🔸 **일관성(Consistency)**: **시스템 고정 요소는 트랜잭션 이후에도 같아야 함** <br>
ㅤㅤ🔸 **고립성(Isolation)**: **트랜잭션 실행 도중 다른 트랜잭션의 영향을 받지 말아야 함** <br>
ㅤㅤ🔸 **지속성(Durability)**: **트랜잭션의 결과는 항상 유지되어야 함** <br>
ㅤ🔻 **제어** <br>
ㅤㅤ🔸 Active: `실행 중`인 상태 <br>
ㅤㅤ🔸 **Failed**: `연산 실행 중 오류`로 인해 더 이상 연산이 진행될 수 없는 상태 <br>
ㅤㅤ🔸 **Aborted**: 트랜잭션 실패로 `트랜잭션 실행 전 상태로 복구(ROLLBACK)` 된 상태 <br>
ㅤㅤ🔸 **Partially Committed**: 마지막 연산을 끝내고 `결과를 반영하기 직전`의 상태 <br>
ㅤㅤ🔸 **Committed**: 연산을 완료하고 `결과를 데이터베이스에 반영`한 상태 <br>
ㅤㅤ🔸 **Undo**: 변경되었던 데이터를 취소하고 `원래의 내용으로 복원` <br>
ㅤㅤ🔸 **Redo**: `Undo 작업 실행 전`으로 다시 복구 <br>

✔  **절차형 SQL** <br>
ㅤ: **순차적인 SQL문의 실행, 분기, 반복을 활용**하여 다양한 기능을 수행하는 **모듈** <br>
ㅤ🔻 **프로시저(Procedure)**: **호출을 통해 실행**되는 절차형 SQL. `반환값이 존재하지 않음` <br>
ㅤ🔻 **사용자 정의 함수(User Defined Function)**: **호출을 통해 실행**되는 절차형 SQL. `반환값이 존재` <br>
ㅤ🔻 **트리거(Trigger)**: DB의 이벤트 발생에 의해 **자동으로 호출**되는 절차형 SQL. `반환값이 존재하지 않음` <br>

✔  **인덱스와 뷰** <br>
ㅤ🔻 **인덱스(INDEX)**: 저장된 데이터를 빠르게 검색할 수 있도록 구성된 자료 구조 및 방법. **너무 넓은 범위는 오버헤드 발생** <br>
ㅤ🔻 **뷰(VIEW)**: 다른 테이블로부터 유도된 **논리적인 가상 테이블**, **인덱스 사용 X, 수정 X, 종속된 테이블 제거 시 함께 제거** <br>

✔  **SQL 지원도구** <br>
ㅤ🔻 **시스템 카탈로그(=데이터 사전)** <br>
ㅤㅤ: 데이터베이스의 객체들에 대한 `정의와 명세`를 **메타 데이터** 형태로 유지 관리하는 시스템 테이블 <br>
ㅤㅤㅤ🔸 **데이터 디렉토리**: DBMS에 의해서만 접근 가능한 데이터 사전 접근 정보 <br>
ㅤㅤㅤ🔸 **메타 데이터**: 다른 데이터를 설명하기 위한 데이터 <br>
ㅤㅤ❗ 시스템 카탈로그는 **DML을 통해 내용 조회는 가능**하지만 **직접적인 변경은 불가함** <br>
ㅤㅤ❗ DBMS 접속 응용 시스템으로는 **JDBC, MyBatis**가 있다. <br>
ㅤ🔻 **SQL 지원 도구** <br>
ㅤㅤ: PL/SQL, SQL*Plus, APM, TKPROF, EXPLAIN PLAN, 소스 코드 인스펙션 도구 등이 있다. <br>

✔  **병행 제어와 로킹** <br>
ㅤ🔻 **병행제어(Concurrency Control, 동시성 제어)** <br>
ㅤㅤ: DB의 활용도를 최대화하기 위해 여러 사용자들의 `DB 공동 사용을 최대화`하는 기술<br>
ㅤㅤ❗ 문제점: **Lost Update, Inconsistency, Cascading Rollback, Uncommitted Dependency** <br>
ㅤ🔻 **로킹(Locking)** <br>
ㅤㅤ: 트랜잭션이 갱신 중인 데이터를 다른 트랜잭션이 `접근하지 못하도록` 잠그는 것<br>
ㅤㅤ✅ **로크 단위 ↑ = 로크 개수 ↓ = 병행성(공유도) ↓ = 오버헤드 ↓ = 병행 제어 기법 단순** <br>
ㅤㅤ❗ 병행 제어 기법으로는 **타임 스탬프 기법, 낙관적 병행 제어(OCC) 기법, 다중 버전 병행 제어(MVCC) 기법**이 있다. <br>
ㅤ🔻 **회복(Recovery)**: **트랜잭션 장애, 시스템 장애, 미디어 장애**로 부터 복원하는 것<br>
ㅤㅤ❗ 키워드: **즉시 갱신, 지연 갱신, CheckPoint, 그림자 페이징 기법(복사본으로 대체)** <br><br><br>

## 💠Chapter 03. 물리 데이터베이스 설계
### 🔹Section 01. **물리 속성 조사 분석 ( ⭐ )**
> [!IMPORTANT]  
> - [ ] **시스템 파악 | 이중화 | 접근제어**

✔  **시스템 자원 체계 파악** <br>
ㅤ: DB 설치 및 운용에 영향을 끼치는 물리적인 요소들. **하드웨어, OS/DBMS 버전, DBMS 파라미터 정보** 등을 파악한다.<br>

✔  **데이터베이스 관리 요소** <br>
ㅤ🔻 **이중화 구성**: 장애 발생 시 동일하게 구성된 DB를 통해 복구<br>
ㅤ🔻 **분산 데이터베이스**: **네트워크**를 통해 하나의 DB처럼 관리 <br>
ㅤ🔻 **접근제어**: DBMS 자체적인 보안은 강력하기에 **사용자의 권한 오남용**을 제어하는 수단(DAC; 임의 접근 통제)을 파악<br>
ㅤ🔻 **DB 암호화** <br><br><br>

### 🔹Section 02. **데이터베이스 물리 속성 설계 ( ⭐ )**
> [!IMPORTANT]  
> - [ ] **인덱스 테이블 | 분할 테이블 | 스토리지 | 파티셔닝**

✔  **저장 레코드 유형** <br>
ㅤ🔻 **일반 유형 테이블(Heap-Organized)**: **대부분의 DBMS에서 표준 테이블**로 사용. ROW의 저장 위치는 ROW가 삽입될 때 결정됨<br>
ㅤ🔻 **클러스터 인덱스 테이블**: **기본키 및 인덱스 등의 순서를 기반**으로 데이터가 저장되는 테이블, 검색속도는 빠르지만 나머지는 느림 <br>
ㅤ🔻 **비 클러스터형 인덱스**: `데이터 페이지와 인덱스 페이지를 분리`하여 구성한 테이블. 인덱스엔 **데이터가 저장된 위치(RID[^51]) 저장** <br>
ㅤ🔻 **수평 분할 테이블(Sharding)**: 릴레이션 스키마를 `복제`하여 **분할 키(Partitioning Key)** 를 기준으로 분산 저장하는 테이블 <br>
ㅤ🔻 수직 분할 테이블(Vertical): 릴레이션 스키마를 `분할`하여 분산 저장하는 테이블. 사용 빈도가 적은 컬럼과 자주 사용하는 컬럼을 분리하여 성능 향상 <br>
ㅤ🔻 외부 테이블(External): `외부 파일을 연결하여 DB 내의 일반 테이블처럼 사용`할 수 있도록 DBMS와 연결된 테이블. 데이터웨어하우스에서의 작업용<br>
ㅤ🔻 임시 테이블(Temporary): 트랜잭션 및 세션별로 데이터를 저장하고 처리할 수 있는 테이블. 절차적 처리를 위한 임시적으로 사용 가능 <br>

[^51]: **Record Identifier / Rowid**

✔  **클러스터링(Clustering)** <br>
ㅤ: 효율 향상을 위해 **특정 기준으로 분류**된 동일한 성격의 데이터를 **동일한 데이터 블록에 저장**하는 물리적인 저장 기법<br>
ㅤ🔻 **특징** <br>
ㅤㅤ**1️⃣** 테이블에 **클러스터드 인덱스**를 생성하여 접근 성능 향상 <br>
ㅤㅤ**2️⃣** 데이터 분포도가 넓은 테이블은 클러스터링을 통해 **저장 공간 절약 가능** <br>
ㅤㅤ**3️⃣** 처리 범위가 넓은 경우 `단일 테이블 클러스터링`을, 조인이 많은 경우 `다중 테이블 클러스터링`을 적용한다. <br>
ㅤㅤ❗데이터 변경이나 전체 테이블 탐색이 자주 발생하는 경우 클러스터링 비추천 <br>
ㅤㅤ❗파티셔닝된 테이블은 클러스터링 불가. <br>

✔  **파티셔닝(Partitioning)** <br>
ㅤ: 대용량 테이블을 **논리적인 작은 테이블로 나누어** 성능 저하 방지와 관리를 용이하게 하는 것 <br>
ㅤ🔻 **유형** <br>
ㅤㅤ**1️⃣** **범위(Range) 분할**: **지정한 컬럼 값을 기준**으로 분할<br>
ㅤㅤ**2️⃣** **해시(Hash) 분할**: **해시 함수**에 따라 데이터 분할<br>
ㅤㅤ**3️⃣** **조합(복합, Composite) 분할**: **범위 분할** 후 **해시 분할**로 다시 분할<br>
ㅤㅤ**4️⃣** **목록(List) 분할**: 분할할 항목을 **관리자가 직접 지정** <br>
ㅤ🔻 **파티션의 장점** <br>
ㅤㅤ**1️⃣** 데이터 접근 범위를 줄여 **성능 향상** <br>
ㅤㅤ**2️⃣** 전체 데이터의 훼손 가능성이 감소되어 **데이터의 가용성 증가** <br>
ㅤㅤ**3️⃣** 각 분할 영역을 **독립적으로 백업 및 복구 가능** <br>
ㅤㅤ**4️⃣** **Disk Striping(데이터를 물리적을 나눠 기록) 기능으로 입출력 성능 향상** <br>

✔  **스토리지(Storage)** <br>
ㅤ: 단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 **서버와 저장장치를 연결하는 기술**<br>
ㅤ🔻 **유형** <br>
ㅤㅤ**1️⃣** **DAS(Direct Attached Storage)**: 서버와 저장장치를 `직접 연결`하는 방식. **다른 서버와 파일공유가 불가능** <br>
ㅤㅤ**2️⃣** **NAS(Network Attached Storage)**: 서버와 저장장치를 `네트워크`를 통해 연결. 별도의 파일 관리 기능(**NAS Storage**)로 저장장치 관리 <br>
ㅤㅤ**3️⃣** **SAN(Storage Area Network)**: **DAS의 빠른 처리와 NAS의 파일 공유 장점**을 합친 방식. 전용 네트워크로 서버와 저장장치 연결<br>

✔  **물리 데이터베이스 설계서 작성** <br>
ㅤ🔻 무결성 설계: **데이터의 정확성과 일관성을 유지하여 결손과 부정합이 없음**을 보증하는 특성. `ex. 도메인 / 개체 / 참조 무결성` <br>
ㅤ🔻 트랜잭션 설계: **CRUD 분석(Create, Read, Update, Delete)** <br>
ㅤ🔻 인덱스 설계: **트리 기반 인덱스(B 트리[^52], B+트리[^53])**, 비트맵 인덱스, 함수 기반 인덱스, 도메인 인덱스 <br>

[^52]: 키 값의 크기를 비교하는 하향식 탐색. 모든 단말 노드의 레벨이 같음
[^53]: 경로를 제공하는 인덱스 세트와 데이터 위치를 제공하는 순차 세트로 구성

✔  **분산 데이터베이스** <br>
ㅤ: 물리적으로 분산되어 있는 DB를 단일 DB로 인식할 수 있도록 **논리적으로 통합하여 운용되는 데이터베이스 시스템** <br>
ㅤ🔻 **특징** <br>
ㅤㅤ**1️⃣** 시스템 규모를 **점진적으로 확장** 가능 <br>
ㅤㅤ**2️⃣** **대용량 데이터 처리가 가능** <br>
ㅤㅤ**3️⃣** 특정 DB에 **문제가 발생해도 다른 DB를 사용**할 수 있어 신뢰도 및 가용성이 보장 <br>
ㅤㅤ**4️⃣** **데이터 무결성 훼손과 오류 발생 가능성 상승** <br>
ㅤ🔻 **분산 데이터베이스 관리 시스템의 조건** <br>
ㅤㅤ**1️⃣** **분할 투명성**: 테이블(릴레이션)의 분할 구조를 사용자가 파악할 필요가 없어야 함<br>
ㅤㅤ**2️⃣** **위치 투명성**: 데이터의 물리적인 위치에 대한 고려 없이 어디서든 동일한 명령을 사용할 수 있어야 함<br>
ㅤㅤ**3️⃣** **중복 투명성**: 중복 데이터의 정보를 사용자가 별도로 인지할 필요없이 사용 가능해야 함<br>
ㅤㅤ**4️⃣** **장애 투명성**: 장애가 발생해도 데이터 무결성과 트랜잭션의 원자성이 보장되어야 함<br>
ㅤㅤ**5️⃣** **병행 투명성**: 다수의 트랜잭션이 동시에 수행되어도 결과의 일관성이 유지되어야 함<br>

✔  **보안설계** <br>
ㅤ❗ **접근 통제 구성 요소: 접근 통제 정책, 접근 통제 메커니즘, 접근 통제 보안 모델** <br>
ㅤ🔻 **접근 통제 정책** <br>
ㅤㅤ**1️⃣** **신분 기반 정책**: **단일 사용자** 하나의 객체에 대해 허가를 받는 경우 **IBP[^54]** / **복수 사용자**의 경우 **GBP[^55]** <br>
ㅤㅤ**2️⃣** **규칙 기반 정책**: **사용자 및 객체가 각각** 부여된 기밀분류에 따른 정책 **MLP[^56]** / **조직 내 특정 집단별**의 경우 **CBP[^57]** <br>
ㅤㅤ**3️⃣** 역할 기반 정책: GBP가 변형된 형태. 정보에 대한 사용자의 접근이 **개인의 직무 또는 직책**에 따라 결정<br>
ㅤ🔻 **접근 통제 기술** <br>
ㅤㅤ**1️⃣** **임의 접근 통제(DAC[^58])**: `데이터에 접근하는 사용자의 신원`에 따라 접근 권한을 부여하는 방식 (GRANT, REVOKE) <br>
ㅤㅤ**2️⃣** **강제 접근 통제(MAC[^59])**: `주체와 객체의 등급을 비교`하여 접근 권한을 부여하는 방식 (chmod) <br>
ㅤ🔻 **접근 통제 보안 모델** <br>
ㅤㅤ**1️⃣** **접근 통제 행렬(Access control matrix)**: 접근 주체를 행, 객체를 열로 하여 주체별 객체접근 권한을 표현한 매트릭스 <br>
ㅤㅤ**2️⃣** **기밀성 모델**: 군대 시스템 등 특수한 환경에서 사용되는 무결성보다 기밀성에 중점을 두는 모델 <br>
ㅤㅤ**3️⃣** 무결성 모델: 기밀성 모델 + 정보의 부당 변경 등 방지<br>
ㅤ🔻 **접근 통제 조건** <br>
ㅤㅤ**1️⃣** 값 종속 통제 <br>
ㅤㅤ**2️⃣** 다중 사용자 통제 <br>
ㅤㅤ**3️⃣** 컨텍스트 기반 통제: 특정 외부요소에 근거하여 접근 관리 <br><br><br>

[^54]: **Individual-Based Policy**
[^55]: **Group-Based Policy**
[^56]: **Multi-Level Policy**
[^57]: **Compartment-Based Policy**
[^58]: **Discretionary Access Control**
[^59]: **Mandatory Access Control**

### 🔹Section 03. **물리 데이터베이스 모델링 ( ⭐⭐ )**
> [!IMPORTANT]  
> - [ ] **타입 변환 |** 시스템 카탈로그 **| 반정규화**

✔  **개체를 테이블로 변환** <br>
<div align="center">
  
|**논리 모델**|**물리 모델**|
|:--:|:--:|
|**개체 타입(Entity Type)**|**테이블(Table)**|
|**개체(Entity)**|**로우(Row)**|
|**속성(Attribute)**|**컬럼(Column)**|
|**식별자(UID: Unique IDentifier)**|**후보키(Candidate Key) = 키(Key)**|
|주 식별자(Primary Identifier)|기본키(Primary Key)|
|보조 식별자(Secondary Identifier)|대체키(Alternate Key)|
|외래 식별자(Foreign Identifier)|외래키(Foreign Key)|
</div> <br>

✔  **반정규화(De-Normalization)** <br>
ㅤ: 정규화된 논리 데이터 모델을 `시스템 운영의 단순화`를 위해 **중복, 통합, 분할** 등을 수행하는 데이터 모델링 기법<br>
ㅤ🔻 **중복 테이블 추가**: 특정 범위 또는 많은 양의 데이터를 **자주 처리**하는 경우 수행 <br>
ㅤ🔻 **테이블 조합**: 대부분의 데이터 처리가 둘 이상의 테이블에서 진행되는 경우 수행 <br>
ㅤ🔻 **테이블 분할**: **특정 컬럼의 사용빈도가 높은** 경우 수행 <br>
ㅤ🔻 **테이블 제거**: 더 이상 **액세스되지 않는 테이블**에 대해 수행(유지보수 단계에서 주로 발생) <br>
ㅤ🔻 **컬럼의 중복화**: 자주 사용되는 컬럼이 **서로 다른 테이블에 분산**되어 액세스 범위가 넓어지는 경우 수행 <br><br><br>

## 💠Chapter 04. 데이터 전환
### 🔹Section 01. **데이터 전환 ( ⭐ )**
> [!IMPORTANT]  
> - [ ] **ETL | 데이터 정합성 | 데이터 관리 책임**

✔  **ETL(Extraction, Transformation, Loading :데이터 전환)** <br>
ㅤ: **추출, 변환, 적재** 기능의 영어 앞 글자를 딴 표현. 데이터 추출부터 목적 DB에 맞게 변환, 목적 시스템에 적재하는 일련의 과정을 의미<br>

✔  **데이터 전환 프로세스** <br>
ㅤ**1️⃣** 데이터 전환 계획 및 요건 정의 단계: **As-Is 분석[^60], To-Be 분석[^61]** <br>
ㅤ**2️⃣** 데이터 전환 설계 단계: **로지컬 매핑(Logical Mapping)[^62], 코드 매핑(Code Mapping)[^63], 검증 규칙(Rule) 정의** <br>
ㅤ**3️⃣** 데이터 전환 개발 단계 <br>
ㅤ**4️⃣** 데이터 전환 테스트 및 검증 단계 <br>
ㅤ**5️⃣** 데이터 전환 단계 <br><br><br>

[^60]: 장비, 솔루션, 네트워크 구성, 데이터 형식 및 크기 파악
[^61]: 목표 시스템 분석 및 데이터베이스 구조 분석
[^62]: 데이터 ETL 로직과 영역별 업무 흐름 반영
[^63]: 원천 데이터 분석 결과를 기반으로 To-Be 정의, 매핑 관계 기술

----------------------------------------------------------------------------------------------------------------------------

# ✳️ 과목 4. 프로그래밍 언어 활용
## 💠Chapter 01. 프로그래밍 개발 환경 구축
### 🔹Section 01. **프로그래밍 개발 환경 구성 ( ⭐ )**
> [!IMPORTANT]  
> - [ ] **언어별 특징 | 배치 프로그램**

✔  **프로그램 개발 언어** <br>
ㅤ🔻 **저급 언어와 고급 언어** <br>
ㅤㅤ**1️⃣** **저급 언어**: 배우기 어렵고 성능이 빠른 언어. 기계친화적, 호환성 낮음 `ex. 기계어, 어셈블리어 등`<br>
ㅤㅤ**2️⃣** **고급 언어**: 배우기 쉽고 성능이 느린 언어. 인간친화적, 호환성 높음 `ex. C, Java, Python 등` <br>
ㅤ🔻 **언어 번역 프로그램(=언어 번역기)** <br>
ㅤㅤ**1️⃣** **어셈블러**: **어셈블리어 코드 번역**. 명령 연산 기호화 기계어를 1:1 대응<br>
ㅤㅤ**2️⃣** **컴파일러**: 고급 언어 코드 **전체 번역**. 번역 속도 느림. 실행 속도 빠름<br>
ㅤㅤ**3️⃣** **인터프리터**: 고급 언어 코드 **행 단위 번역**. 번역 속도 빠름. 실행 속도 느림<br>

✔  **프로그래밍 언어의 종류** <br>
ㅤ🔻 **C**: **UNIX 운영체제 구현**을 위해 개발된 언어. 최근까지도 가장 많이 사용되는 시스템 프로그래밍 언어 <br>
ㅤ🔻 **C++**: **C언어와 객체지향 기술을 통합**한 프로그래밍 언어 <br>
ㅤ🔻 **Java**: **객체지향 프로그래밍**을 위해 개발된 언어. **컴파일**을 통해 생성된 class파일을 가상 머신을 통해 실행. Garbage Collector<br>
ㅤㅤㅤ❗ **컴파일(Compile)**: **문법 확인**및 **기계어로 변환**하는 기능 제공<br>
ㅤ🔻 **JavaScript**: **웹 페이지 동작을 구현하는 객체지향 스크립트 언어**. 프로토타입을 기반으로 객체 상속 가능 <br>
ㅤ🔻 **Python**: 다양한 라이브러리를 제공하며 **동적 타이핑을 지원하는 객체지향 스크립트 언어** <br>
ㅤ🔻 **PHP**: **HTML에 포함되어 동작**하는 서버측 스크립트 언어 <br>

✔  **배치 프로그램** <br>
ㅤ: 사용자의 상호작용 없이 일련의 작업들을 **정기적으로 반복 수행**하거나 **정해진 규칙에 따라 일괄 처리**하는 기능을 가진 프로그램<br>
ㅤㅤ`ex. Spring Batch, Quartz Scheduler` <br><br><br>

## 💠Chapter 02. 절차형 프로그래밍 언어
### 🔹Section 01. **데이터 가공 및 입출력 ( ⭐⭐⭐ )**
> [!IMPORTANT]  
> - [ ] **상수| 예약어 | 변수 선언 | 기본 함수 | 연산자 우선순위**

✔  **자료형** <br>
ㅤ🔻 C언어 기본 작성 규칙: `main 함수`를 호출하며 시작. 대소문자를 엄격하게 구분하며 모든 명령문은 세미콜론;으로 마무리 <br>
ㅤ🔻 **상수 표현**: 10진수(24),8진수(023), 16진수(0xD2), 지수(12e3=12*10^3), 문자('a'), 문자열("Apple")<br>
ㅤ🔻 변수 선언 규칙: 헝가리안 표기법(이름 앞에 데이터 타입을 적는 형식, 지금은 권장하지 않음)<br>
ㅤ🔻 **대표적인 자료형** <br>

|**예약어**|**자료형**|**C (Byte)**|**Java (Byte)**|
|:--:|:--:|:--:|:--:|
|byte|정수형|x|1|
|**short**|정수형|2|2|
|**int**|정수형|4|4|
|**long**|정수형|4|8|
|**char**|문자형|1|2|
|**float**|실수형|4|4|
|**double**|실수형|8|8|

✔  **서식 문자열** <br>
ㅤ🔻 이스케이프 시퀀스: \n(줄바꿈), \t(Tab), \b(←; 커서 한 칸 이동), \r(Home 키;행 맨 앞으로 이동), \\('\'출력) <br>
ㅤ🔻 **서식 지정자**: **%d(10진수)**, %o(8진수), %x(16진수), **%u(부호 없는 정수)**, **%lf(실수)**, %e(지수 형태 실수), %c(문자), %s(문자열) <br>

✔  **표준 입출력 함수** <br>
ㅤ🔻 **입력 함수**: getchar(<문자>), gets(<문자열>), scanf(<"서식 문자열">, <&변수명>) <br>
ㅤ🔻 **출력 함수** putchar(<문자>), puts(<문자열>), printf(<"서식 문자열">, <&변수명>) <br>

✔  **연산자** <br>
ㅤ🔻 산술 연산자: +, -, *, /(**정수/정수: 몫, 정수/실수: 나눗셈**), % <br>
ㅤ🔻 관계 연산자: >, >=, <, <=, ==, != <br>
ㅤ🔻 논리 연산자: &&, ||, ! <br>
ㅤ🔻 비트 연산자: &(and 연산), |(or 연산), ^(xor 연산), ~(not 연산), >>(우측으로 n만큼 이동), <<(좌측으로 n만큼 이동) <br>
ㅤ🔻 복합 대입 연산자: +=, -=, *=, /=, %= <br>
ㅤ🔻 전치/후치 증감 연산자: a++, ++a, a--, --a <br>

### 🔹Section 02. **선택 및 반복 제어문 ( ⭐⭐⭐ )**
> [!IMPORTANT]  
> - [ ] **if | for | while | 표준 라이브러리**

✔  **선택 제어문** <br>
ㅤ**1️⃣** **if-else** <br>
ㅤㅤ🔻 **if / else if / else**: `if(<조건>)`. **삼항 연산자**로 표현 가능 `(<조건식>?<참 일 때 값>:<거짓 일 때 값>)` <br>
ㅤ**2️⃣** **switch-case-default** <br>
ㅤㅤ🔻 **switch**: 특정 데이터를 단일 값과 비교(case별 비교)하여 명령 실행. `default는 if-else문의 else와 같은 역할` <br>

✔  **반복문** <br>
ㅤ**1️⃣** **횟수 제한 반복문** <br>
ㅤㅤ🔻 **for문**: `for(<초기식>; <종료분기(초기값 종료 조건식)>; <증감식>;){<반복 구역>}` <br>
ㅤㅤㅤㅤ❗ `continue`: **continue문 아래의 남은 코드를 무시하고 다음 반복 회차를 진행한다.** <br>
ㅤ**2️⃣** **조건 제한 반복문** <br>
ㅤㅤ🔻 **while**: `while(<조건>){<반복 영역>}`. 조건을 먼저 판단한 다음, 코드 반복<br>
ㅤㅤ🔻 do-while: `do{<반복 구역>}while(<조건>);`. 코드를 먼저 실행한 다음, 조건을 판단<br>
ㅤㅤ🔻 무한반복(Loop): 결과가 항상 참일 경우 반복 구역을 무한 반복<br>

✔  **함수** <br>
ㅤ🔻 **표준 라이브러리** <br>
<div align="center">
  
|**라이브러리**|**제공 기능**|**함수명**|**기능**|**라이브러리**|**제공 기능**|**함수명**|**기능**|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|**stdio.h**|데이터 입출력|printf()|기본 출력|**stdlib.h**|기본 데이터 관련|atoi()|문자열 → 정수(int)|
|||scanf()|기본 입력|||atof()|문자열 → 실수(float)|
|||getchar()|문자 하나 입력|||atol()|문자열 → 정수(long)|
|||putchar()|문자 하나 출력|||rand()|난수|
|**math.h**|수학|sqrt()|제곱근|**string.h**|문자열 처리|strlen()|문자열 길이|
|||pow()|제곱수|||strcpy()|문자열 복사|
|||abs()|절대값|||strcmp()|문자열 비교|
</div> 

ㅤ🔻 **함수의 정의와 호출** <br>
ㅤㅤ: 함수는 main 함수 블록 바깥에 정의. `<반환 타입> <함수명>(<매개변수>){코드}` (※ 반환값이 없는 경우 **void** 입력)<br>
ㅤ❓ **인수**: 함수 외부에서 함수로 넘겨주는 값  /  **매개변수**: 인수를 할당받는 변수 <br><br><br>

### 🔹Section 03. **자료 구조와 포인터 ( ⭐⭐⭐ )**
> [!IMPORTANT] 
> - [ ] **배열 | 포인터 | 포인터 연산**

✔  **배열** <br>
```C++
# 배열의 선언
## <자료형> <배열명>[<크기>];
double arr[3];

# 배열의 초기화
int arr[5]={2,4,6}    // 2,4,6,0,0으로 초기화 (입력이 없는 경우 자동으로 0으로 초기화 됨)

# 인덱스
arr[-1]     // 오류 (python과 달리 음수를 입력하면 오류 발생)

# 2차원 배열
## <자료형> <배열명>[<1차원 배열 크기>][<2차원 배열 크기>];
int graph[2][3]={1,2,3,4,5}  // 1 2 3
                             // 4 5 0

int graph[2][3]={{1,2}, {3,4,5}}   // 1 2 0
                                   // 3 4 5

# 구조체
## <struct> <구조체 타입명>{ <변수 선언>[, ...]};

struct student{                        // 구조체 정의
    int no;
    char name [10];
    float score;
    char grade;
};

int main(){
    struct student kim = {001, "kimss", 97.1, 'A'};  // student 타입 구조체 변수선언 및 초기화
    kim.score = 24.1;                                // 구조체 변수 데이터 할당 (변수 값 변경)

    printf("%f %c", kim.score, kim.grade);
    return 0;
};

>> 24.1 A
```
ㅤ❗ **구조체(사용자 정의 자료형)** <br>
ㅤㅤ**1️⃣** C언어에서 기본으로 제공되는 자료형을 이용해 **새로운 자료형을 만드는 것** <br>
ㅤㅤ**2️⃣** 배열과 달리 **하나의 식별자로 서로 다른 형식의 데이터를 그룹으로 관리 가능** <br>
ㅤㅤ**3️⃣** 기존에 없던 자료형이므로 선언하기 전 **자료형에 대한 정의**가 우선되어야 함 <br>
ㅤㅤ**4️⃣** `구조체 정의 단계`에서는 **내부 변수를 초기화하지 않는다** <br>

✔  **포인터** <br>
ㅤ: 식별자(변수명, 배열명)가 아닌 **주소값으로 특정 데이터에 접근할 수 있는 기능**. `복사된 데이터`가 아닌 **원본 데이터를 가공할 수 있다** <br>
ㅤㅤ❗ 배열에서의 주소값은 `배열 데이터의 첫 번째 시작 위치값`을 가진다. <br>
ㅤ🔻 **포인터 연산자** <br>
ㅤㅤ**1️⃣** **&**: 식별자 앞에 붙여서 **해당 식별자의 주소값 도출** <br>
ㅤㅤ**2️⃣** **\***: 주소 데이터 앞에 붙여서 **해당 위치로 접근** <br>
ㅤㅤ❗ **포인터 변수**: **특정 데이터의 주소값을 저장하는 변수**. 식별자 앞에 *을 붙여 선언한다. <br>

```C
# 예시 1
int data=10;    
int *p;          // 포인터 변수 p 선언
p=&data;         // 변수 data의 주소값 할당
*p=20;           // p가 가리키는 변수(data)에 20 할당
printf("%d %d", data, *p);

>> 20 20

# 예시 2
void fa(int x, int *y){     // 참조값을 전달받는 변수는 포인터 변수로 선언
  x = x + 5;                // n과 x는 서로 독립적이지만, k와 *y는 같은 데이터
  *y = *y + 5;              // y가 가리키는 변수 k값이 5 증가 
  return;
}

int main(){
  int n=10, k=20;
  fa(n, &k);              // n은 값이 복사되어 전달, k는 참조값이 전달
  printf("%d %d", n, k);
  return 0;
}

>> 10 25
```

ㅤ🔻 **포인터 연산**: 데이터의 주소값을 가감 연산하는 경우, **해당 데이터의 크기를 곱한 값으로 증감** <br>
ㅤㅤ`ex. int형 데이터의 주소값에 2를 더한 경우: 2 * 4(int 타입 크기)만큼 증가`

```C
# 예시 1
int arr[5]={1,2,3,4,5};
int *p=arr;                  // 포인터 변수 p에 배열 arr 주소값 할당
printf("%d\n", p[2]);        // p가 가리키는 데이터 값 출력 (3)
printf("%d\n", *(p+2);       // p+2*4가 가리키는 데이터 값 출력 (3)
printf("%d\n", *(arr+2));    // arr+2*4가 가리키는 데이터 값 출력 (3)

# 예시 2
int arr[2][3]={1,2,3,4,5,6};
int (*p)[3]=arr;                // 2차원 포인터 변수 p에 2차원 배열 arr 주소값 할당
                                // 포인터 연산: N*4(int)*3(배열크기)
printf("%d\n", *(p[1]+2));      // p[1][2]와 같은 위치 참조 (6)
printf("%d\n", *(*(p+1)+0));    // p[1][0]과 같은 위치 참조 (4)
```

<br><br>

## 💠Chapter 03. 객체지향 프로그래밍 언어
### 🔹Section 01. **객체지향 방법론 ( ⭐⭐⭐ )**
> [!IMPORTANT]  
> - [ ] **객체 용어 | 객체 기술 | 디자인 패턴 | 럼바우**

✔  **객체지향 기술** <br>
ㅤ❓ **속성**: 객체에 포함되는 자료 구조, 상태값 등  /  **메소드**: 속성에 대한 연산 및 고유 수행 기능 등 <br>
ㅤ🔻 **객체지향 기술의 구성 요소** <br>
ㅤㅤ**1️⃣** **클래스(Class)**: 객체의 타입을 정의하고 구현하는 틀(Frame) <br>
ㅤㅤ**2️⃣** **객체(Object)**: 클래스에 의해 구현된 각각의 대상들을 총칭<br>
ㅤㅤ**3️⃣** **인스턴스(Instance)**: 특정 클래스에 의해 구현된 좁은 범위의 객체<br>
ㅤㅤ**4️⃣** **메시지(Message)**: 객체 간 통신(상호작용)을 위해 서로 주고받는 인터페이스<br>
ㅤㅤ**5️⃣** **메소드(Method)**: 요청 메시지에 의해 객체가 수행해야 할 연산을 정의한 것 <br>
ㅤ🔻 **객체지향 기술** <br>
ㅤㅤ**1️⃣** **캡슐화(Encapsulation)**: 문제 해결에 필요한 **속성과 메소드를 하나로 묶는 것** <br>
ㅤㅤ**2️⃣** **정보은닉(Information Hiding)**: 실제 구현되는 **내용의 일부를 외부로부터 감추는 것** (외부로부터 속성과 메소드 보호) <br>
ㅤㅤ**3️⃣** **추상화(Abstract)**: 클래스들의 **공통된 요소를 추출하여 상위 클래스로 구현** <br>
ㅤㅤ**4️⃣** **상속(Inheritance)**: 상위 클래스의 멤버(속성, 메소드)를 하위 클래스에 물려받도록 하는 것 <br>
ㅤㅤ**5️⃣** **다형성(Polymorphism)**: 상속된 여러 하위 객체들이 **서로 다른 형태를 가질 수 있게 하는 것** `ex. 오버로딩, 오버라이딩`<br>
ㅤㅤㅤㅤ❗ **오버로딩**: 동일한 이름의 메소드여도 **매개변수로 구분**하여 적절한 메소드를 호출해주는 기능 <br>
ㅤㅤㅤㅤ❗ **오버라이딩**: 상속받은 메소드의 내부 기능을 **새롭게 정의**하는 기능 <br>

✔  **객체지향 분석 방법론** <br>
ㅤㅤ**1️⃣** **Rumbaugh(럼바우)**: `SW의 구성 요소`를 다양한 **그래픽 표기법을 이용하여 모델링**하는 기법. 분석 절차: **객체→동적→기능** 모델링<br>
ㅤㅤㅤ🔻 **객체 모델링**: 객체 다이어그램을 활용하여 객체와 객체 간의 관계 정의 <br>
ㅤㅤㅤ🔻 **동적 모델링**: 상태, 활동 다이어그램을 활용하여 기능의 흐름을 표시 <br>
ㅤㅤㅤ🔻 **기능 모델링**: 자료 흐름도(DFD)를 활용하여 입출력 데이터, 세부 기능 결정 <br>
ㅤㅤ**2️⃣** Booch: 클래스와 객체들을 분석 및 식별, 클래스의 속성과 연산 정의. **미시+거시적 개발 프로세스** 모두 사용하는 분석 기법 <br>
ㅤㅤ**3️⃣** Jacobson: **유스케이스**를 활용하여 분석하는 기법<br>
ㅤㅤ**4️⃣** Coad와 Yourdon: **E-R 다이어그램**을 사용하여 객체의 행위를 모델링하는 분석 기법 <br>
ㅤㅤ**5️⃣** Wirfs-Brock: 분석과 설계의 구분이 없고, **고객 명세서**를 평가하여 설계 작업까지 연속적으로 수행 <br>

✔  **객체지향 설계 원칙** <br>
ㅤㅤ**1️⃣** 단일 책임: **하나의 클래스**가 제공하는 모든 기능이 **하나의 문제만 해결**하도록 설계해야한다. <br>
ㅤㅤ**2️⃣** 개방 폐쇄: `확장`에 대해서는 **개방적**, `수정`에 대해서는 **폐쇄적**이어야 한다. <br>
ㅤㅤ**3️⃣** **리스코프 치환**: **하위 클래스는 상위 클래스의 기능이 호환**될 수 있어야 한다.<br>
ㅤㅤ**4️⃣** 인터페이스 분리: 하나의 포괄적인 인터페이스보다는 **다수의 구체적인 인터페이스**를 구성해야 한다.<br>
ㅤㅤ**5️⃣** 의존성 뒤집기: `하위 클래스의 변경 사항`이 **상위 클래스에 영향을 미치지 않도록** 구성해야 한다. <br>

✔  **객체지향 테스트** <br>
ㅤ🔻스레드 기반 테스트(Thread-Based Testing): **하향식** <br>
ㅤ🔻사용-기반 테스트(Use-Based Testing): **상향식** <br>

✔  **디자인 패턴** <br>
ㅤ: 반복적인 문제들의 해결하기 위한 **설계 패턴을 일반화** 한 것. **GoF(Gang of Four) 디자인 패턴**이라고도 함. <br>
ㅤ🔻**생성 패턴**: 클래스 정의, 객체 생성 방식에 적용 가능한 패턴 <br>
ㅤㅤ**1️⃣** **Factory Method**: **객체를 생성하여 반환**하는 메소드. 이런 팩토리 메소드를 **오버라이딩**하여 객체를 반환하는 패턴<br>
ㅤㅤ**2️⃣** **Abstract Factory**: 관련이 있는 **서브 클래스를 묶어서 팩토리 클래스**로 만들고, 조건에 따라 객체를 생성하는 패턴<br>
ㅤㅤ**3️⃣** **Builder**: 객체 생성에 많은 인수가 필요한 **복잡한 객체를 단계적으로 생성**하는 패턴 <br>
ㅤㅤ**4️⃣** **Prototype**: 새로운 객체를 생성하는 것이 아닌 **기존의 객체를 복사**하여 특정 속성값을 변경 <br>
ㅤㅤ**5️⃣** **Sigleton**: **클래스가 오직 하나의 인스턴스**만을 가지도록 하는 패턴. **접근제한자와 정적 변수**를 활용<br>
ㅤ🔻**구조 패턴**: 객체 간 구조와 인터페이스에 적용 가능한 패턴 <br>
ㅤㅤ**1️⃣** **Adaptor**: 서로 다른 인터페이스를 가진 클래스들을 함께 사용할 수 있도록 하는 패턴<br>
ㅤㅤ**2️⃣** **Bridge**: 복잡한 클래스를 **기능부와 구현부로 분리**한 뒤, 두 클래스를 **연결**하는 패턴<br>
ㅤㅤ**3️⃣** **Composite**: **다수의 클래스를 하나의 클래스로 취급** ❗추상 팩토리와 헷갈림 주의 <br>
ㅤㅤ**4️⃣** **Decorator**: 클래스의 변경 없이 주어진 상황에 따라 기능을 추가 <br>
ㅤㅤ**그 외**: Facade(겉모습; 단순화된 인터페이스 제공), Flyweight(메모리 사용량 최소화하기 위해 객체간 데이터 공유 극대화) <br> 
ㅤㅤㅤㅤㅤ, Proxy(대리자를 통한 객체 접근)<br>
ㅤ🔻**행위 패턴**: 기능(알고리즘), 반복적인 작업에 적용 가능한 패턴 <br>
ㅤㅤ**1️⃣** **Interpreter**: 언어의 문법을 **평가(해석)하는 방법**을 규정하는 패턴 <br>
ㅤㅤ**2️⃣** **Command**: **요청을 객체의 형태로 캡슐화**하여 정보 요청에 필요한 정보 저장하는 패턴 <br>
ㅤㅤ**3️⃣** **Mediator**: 객체 간의 통신이 **중재자**를 통해 진행되어 **결합도를 감소**시키는 패턴 <br>
ㅤㅤ**그 외**: Observer(객체의 상태 변화 관찰), State(객체의 내부 상태에 따라 다른 기능 수행)<br>
ㅤㅤㅤㅤㅤ,Visitor(알고리즘을 자료 구조에서 분리), Memento(롤백 기능 제공) 등 <br>
<div align="center">

  |**생성**|**구조**|**행위**|
|:--:|:--:|:--:|
|**Factory Method**|**Adaptor** / **Bridge**|**Interpreter** / **Mediator** / Memento|
|**Abstract Factory**|**Composite** / **Decorator**|Template Method / **Observer**|
|**Builder**|Facade|Chain of Responsibility / **State**|
|**Prototype**|Flyweight|**Command** / Strategy|
|**Sigleton**|**Proxy**|Iterator / **Visitor**|

</div> <br>

### 🔹Section 02. **객체지향 프로그래밍 ( ⭐⭐⭐ )**
> [!IMPORTANT]  
> - [ ] **클래스 | 인스턴스 | 상속 | 추상 클래스 | 인터페이스**

✔  **클래스** <br>
ㅤ🔻**멤버**: 클래스의 구성 요소로 `멤버 변수`와 `멤버 메소드`가 있다. 일반적으로 클래스의 외부 접근이 불가하도록 **캡슐화**되어야 함<br>
ㅤㅤ**1️⃣** **멤버 변수**: 객체의 상태, 수치, 특성을 나타내는 변수 <br>
ㅤㅤ**2️⃣** **멤버 메소드**: 객체에서 발생하는 모든 제어 및 기능, 요청 행위 <br>
ㅤ🔻**기본 출력 메소드** <br>
```java
* 더하기 연산을 이용해 문자열과 숫자의 결합이 가능
System.out.print();     # 출력
System.out.println();   # 출력+줄 바꿈
System.out.printf();    # 서식에 의한 출력
```
ㅤ🔻**접근제한자**: 클래스 내 멤버들의 **접근 수준**을 결정하는 토큰. `프로그램→ 패키지→ 하위 클래스→ 자신의 클래스` 순으로 접근 수준을 결정<br>
<div align="center">
  <img width="65%" height="100%" src="https://github.com/Kim-SeongSu/Self-study_and_Review/assets/104110605/35766fdf-2159-4210-abed-75de37e6539b">
</div><br>

✔  **인스턴스** <br>
```java
# 인스턴스 생성
  : 새로운 인스턴스를 생성하여 적절한 타입의 참조형 변수에 할당하는 작업
<클래스명> <변수명> = new <클래스명>();

# 인스턴스의 멤버 접근
<객체 변수>.<멤버이름>;
```
ㅤㅤ❗**기본형 변수(Primitive Variable)**: 값을 저장하는 저장공간으로 **리터럴(실제값)** 이 저장됨 `ex. 10, a, true ...`<br>
ㅤㅤ❗**참조형 변수(Reference Variable)**: 리터럴이 아닌 **주소값(메모리 주소)** 이 저장됨 <br>
ㅤ🔻**멤버 변수**: 클래스 내부에 생성된 변수. `인스턴스 변수`와 `클래스 변수`가 있다. <br>
ㅤㅤ**1️⃣** **인스턴스 변수**: 인스턴스마다 독립적으로 존재하며 접근을 제한(private)해 두는 것이 일반적 `ex. int a;` <br>
ㅤㅤ**2️⃣** **클래스 변수**: 같은 클래스로부터 생성된 `모든 인스턴스가 함께 공유하는 데이터가 필요할 때` 사용 `ex. static int a;` <br>
ㅤ🔻**지역 변수**: 클래스 내부의 **또 다른 구역**(새롭게 정의된 메소드 안)에 생성된 변수. <br>
ㅤㅤ✅ 지역 변수와 멤버 변수의 이름이 같은 경우엔 **this** 키워드(멤버변수에 붙임)로 구분하여 접근할 수 있음 <br>

✔  **생성자 메소드** <br>
ㅤ: 클래스 내부에 **클래스명과 같은 이름으로 존재하는 특별한 메소드**. <br>
ㅤ🔻**특징** <br>
ㅤㅤ**1️⃣** 인스턴스가 생성될 때 자동으로 실행 됨 <br>
ㅤㅤ**2️⃣** 별도로 실행할 수 없음 <br>
ㅤㅤ**3️⃣** 리턴문 사용 불가 <br>
ㅤㅤ**4️⃣** 인스턴스 생성 시 멤버변수 및 연관 객체들의 초기화 작업에 사용됨<br>
ㅤㅤ**5️⃣** 생성자 역시 메소드이므로 **오버로딩** 가능 <br>

✔  **객체지향 기술 적용** <br>
ㅤ🔻**상속** <br>
ㅤㅤㅤ: 상위 클래스로부터 상속받아 상하위 클래스의 모든 멤버를 포함하여 인스턴스를 생성할 수 있게 하는 기술<br>
```java
class <하위 클래스명> extends <상위 클래스명> {...}
```
ㅤㅤ🔸**메소드 오버라이딩**: `상위 클래스의 메소드`를 **재정의**하여 사용하는 기술. 상위 클래스와 동일한 메소드명과 매개변수를 지정 <br>
ㅤㅤ🔸**업캐스팅**: 상속의 관계에서, `하위 클래스의 인스턴스`를 상위 클래스 타입의 참조형 변수에 할당하는 것 <br>
ㅤ🔻**추상 클래스** <br>
ㅤㅤㅤ: 추상 메소드를 하나 이상 포함하는 클래스. 추상 클래스의 기본 틀 안에서 기능을 구현하게 되므로 클래스의 체계적인 설계가 가능<br>
ㅤㅤ❓**추상 메소드**: **abstract** 키워드를 이용한 선언부만 있고 구현부(중괄호)는 없는 메소드. 반드시 하위 클래스에서 오버라이딩 해서 사용 <br>
ㅤ🔻**인터페이스** <br>
ㅤㅤㅤ: 자바는 둘 이상의 상위 클래스를 상속받는 **다중 상속**을 금지. 이를 방지하면서 다중 상속의 이점을 가질 수 있는 기능이 인터페이스 <br>
ㅤㅤ🔸**특징** <br>
ㅤㅤㅤ**1️⃣** 모든 메소드가 **추상 메소드로만 구성**된 클래스 <br>
ㅤㅤㅤ**2️⃣** 상위 클래스의 상속을 받지 않기 때문에 **다중 상속의 문제를 방지** <br>
ㅤㅤㅤ**3️⃣** 확장된 클래스의 기능을 제한하거나 변경하는 **다형성**의 개념을 갖음 (상속은 기존 클래스의 멤버를 **확장**하는 개념) <br>
ㅤㅤㅤ**4️⃣** **interface(구현)와 implements(상속)** 키워드를 사용하여 구현, 상속 받는다. <br>
ㅤ🔻**예외 처리** <br>
ㅤㅤ🔸**구성** <br>
ㅤㅤㅤ**1️⃣** **try**: 예외 발생을 감지하는 코드 영역 <br>
ㅤㅤㅤ**2️⃣** **catch**: 예외 발생 시 수행되는 코드 영역 <br>
ㅤㅤㅤ**3️⃣** **finally(생략가능)**: 예외 여부와 상관없이 항상 실행되는 블록 <br>
ㅤ🔻**스레드(Thread)** <br>
ㅤㅤㅤ: 하나의 프로세스에서 둘 이상의 일을 동시에 수행하는 것. run 메소드를 오버라이딩하여 스레드를 통해 수행될 코드를 정의<br>
ㅤㅤ**1️⃣** Thread 클래스 상속을 통한 스레드 구현<br>
ㅤㅤ**2️⃣** Runnable 인터페이스 상속을 통한 스레드 구현<br>
ㅤㅤ🔸 **멀티스레딩**: 동시에 여러 활동 가능, 메모리 공유를 통해 시스템 자원 소비 절약, 충돌 및 버그 발생 가능성 높음<br>
ㅤㅤ🔸 **스레드의 상태 전이**: **Runnable / Running / Blocked / Dead(Done)** <br><br><br>

## 💠Chapter 04. 스크립트 프로그래밍 언어
### 🔹Section 01. **파이썬 프로그래밍 ( ⭐⭐⭐ )**

<br><br>

## 💠Chapter 05. 운영체제 활용
### 🔹Section 01. **운영체제 ( ⭐ )**

### 🔹Section 02. **프로세스 ( ⭐⭐⭐ )**

### 🔹Section 03. **기억 장치 관리 ( ⭐⭐ )**

<br><br><br>

<!--
> [!IMPORTANT]  
> - [ ] ****

ㅤ🔻****: <br>

✔  **** <br>
ㅤ🔻 ****: **** <br>
ㅤ: <br>
`ex. `
ㅤㅤ
1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣❗❓✅🔸

[^60] 부터

<div align="center">
  <img width="55%" src="">
</div>

<p align="center"><img src="" width="80%" height="80%"></p>

> [!NOTE]  
> [!TIP]
> [!IMPORTANT]  
> [!WARNING]  
> [!CAUTION]

<div align="center">
  
|****|****|****|
|:--:|:--:|:--:|
||||
</div> <br>

-->

----------------------------------------------------------------------------------------------------------------------------

# ✳️ 과목 5. 정보 시스템 구축 관리

## 💠Chapter 01. IT 프로젝트 정보 시스템 구축 관리
### 🔹Section 01. **네트워크 구축 관리 ( ⭐ )**

### 🔹Section 02. **통신망 기술 ( ⭐⭐ )**

### 🔹Section 03. **통신 프로토콜 ( ⭐⭐⭐ )**

### 🔹Section 04. **정보 시스템 신기술 동향 ( ⭐⭐⭐ )**

<br><br>

## 💠Chapter 02. 개발 보안 구축
### 🔹Section 01. **소프트웨어 개발 보안 구축 ( ⭐ )**

### 🔹Section 02. **시스템 보안 구축 ( ⭐ )**

<br><br>

## 💠Chapter 03. 암호 기술
### 🔹Section 01. **보안 공격 및 예방 ( ⭐⭐⭐ )**

### 🔹Section 02. **보안 솔루션 ( ⭐ )**

### 🔹Section 03. **암호 기술 ( ⭐⭐ )**

<br><br><br>

----------------------------------------------------------------------------------------------------------------------------
